<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>RAMBLE&amp;BB</title><link>https://blog.black-desk.cn/</link><description>Recent content on RAMBLE&amp;BB</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 10 Jul 2022 02:23:58 +0800</lastBuildDate><atom:link href="https://blog.black-desk.cn/index.xml" rel="self" type="application/rss+xml"/><item><title>lambda</title><link>https://blog.black-desk.cn/post/lambda/</link><pubDate>Sun, 10 Jul 2022 02:23:58 +0800</pubDate><guid>https://blog.black-desk.cn/post/lambda/</guid><description>&lt;p>这里整理一些关于&lt;code>c++&lt;/code>中的匿名函数的知识.&lt;/p>
&lt;p>《C++
primer》上有的内容就不在重述了.这里重点讲一些primer上&lt;strong>可能&lt;/strong>没有的东西.&lt;/p>
&lt;h2 id="捕获的时机">捕获的时机&lt;/h2>
&lt;p>primer 向我们介绍到: 有两种捕获变量的方式, 值捕获和引用捕获.
其中:&lt;/p>
&lt;blockquote>
&lt;p>...&lt;/p>
&lt;p>与参数不同,被捕获的变量的值是在lambda创建时拷贝,而不是调用时拷贝&lt;/p>
&lt;p>...&lt;/p>
&lt;p>如果我们采用引用方式捕获一个变量,就必须确保被引用的对象在lambda执行的时候是存在的.lambda捕获的都是局部变量,这些变量在函数结束后就不复存在了.&lt;/p>
&lt;p>...&lt;/p>
&lt;/blockquote>
&lt;p>我们看一段代码:&lt;/p>
&lt;div class="sourceCode" id="cb1">&lt;pre
class="sourceCode cpp">&lt;code class="sourceCode cpp">&lt;span id="cb1-1">&lt;a href="#cb1-1" aria-hidden="true" tabindex="-1">&lt;/a>&lt;span class="kw">auto&lt;/span> funtionTimesMod1&lt;span class="op">(&lt;/span>&lt;span class="dt">int&lt;/span> mod&lt;span class="op">)&lt;/span> &lt;span class="op">{&lt;/span>&lt;/span>
&lt;span id="cb1-2">&lt;a href="#cb1-2" aria-hidden="true" tabindex="-1">&lt;/a> &lt;span class="dt">int&lt;/span> variableA &lt;span class="op">=&lt;/span> mod&lt;span class="op">;&lt;/span>&lt;/span>
&lt;span id="cb1-3">&lt;a href="#cb1-3" aria-hidden="true" tabindex="-1">&lt;/a> &lt;span class="kw">auto&lt;/span> f &lt;span class="op">=&lt;/span> &lt;span class="op">[&lt;/span>variableA&lt;span class="op">](&lt;/span>&lt;span class="dt">int&lt;/span> a&lt;span class="op">,&lt;/span> &lt;span class="dt">int&lt;/span> b&lt;span class="op">)&lt;/span> &lt;span class="op">{&lt;/span> &lt;span class="cf">return&lt;/span> a &lt;span class="op">%&lt;/span> variableA &lt;span class="op">*&lt;/span> b &lt;span class="op">%&lt;/span> variableA&lt;span class="op">;&lt;/span> &lt;span class="op">};&lt;/span>&lt;/span>
&lt;span id="cb1-4">&lt;a href="#cb1-4" aria-hidden="true" tabindex="-1">&lt;/a> &lt;span class="cf">return&lt;/span> f&lt;span class="op">;&lt;/span>&lt;/span>
&lt;span id="cb1-5">&lt;a href="#cb1-5" aria-hidden="true" tabindex="-1">&lt;/a>&lt;span class="op">}&lt;/span>&lt;/span>
&lt;span id="cb1-6">&lt;a href="#cb1-6" aria-hidden="true" tabindex="-1">&lt;/a>&lt;span class="dt">void&lt;/span> test1&lt;span class="op">()&lt;/span> &lt;span class="op">{&lt;/span>&lt;/span>
&lt;span id="cb1-7">&lt;a href="#cb1-7" aria-hidden="true" tabindex="-1">&lt;/a> cout &lt;span class="op">&amp;lt;&amp;lt;&lt;/span> &lt;span class="st">&amp;quot;---test1---&amp;quot;&lt;/span> &lt;span class="op">&amp;lt;&amp;lt;&lt;/span> endl&lt;span class="op">;&lt;/span>&lt;/span>
&lt;span id="cb1-8">&lt;a href="#cb1-8" aria-hidden="true" tabindex="-1">&lt;/a> &lt;span class="dt">int&lt;/span> a &lt;span class="op">=&lt;/span> &lt;span class="dv">10&lt;/span>&lt;span class="op">,&lt;/span> b &lt;span class="op">=&lt;/span> &lt;span class="dv">20&lt;/span>&lt;span class="op">,&lt;/span> c &lt;span class="op">=&lt;/span> &lt;span class="dv">7&lt;/span>&lt;span class="op">;&lt;/span>&lt;/span>
&lt;span id="cb1-9">&lt;a href="#cb1-9" aria-hidden="true" tabindex="-1">&lt;/a> &lt;span class="kw">auto&lt;/span> times &lt;span class="op">=&lt;/span> funtionTimesMod1&lt;span class="op">(&lt;/span>c&lt;span class="op">);&lt;/span>&lt;/span>
&lt;span id="cb1-10">&lt;a href="#cb1-10" aria-hidden="true" tabindex="-1">&lt;/a> cout &lt;span class="op">&amp;lt;&amp;lt;&lt;/span> times&lt;span class="op">(&lt;/span>a&lt;span class="op">,&lt;/span> b&lt;span class="op">)&lt;/span> &lt;span class="op">&amp;lt;&amp;lt;&lt;/span> endl&lt;span class="op">;&lt;/span>&lt;/span>
&lt;span id="cb1-11">&lt;a href="#cb1-11" aria-hidden="true" tabindex="-1">&lt;/a>&lt;span class="op">}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>这里&lt;code>funtionTimesMod1(int mod)&lt;/code>返回一个签名为&lt;code>int(int, int)&lt;/code>的函数,这个函数计算两个参数相乘对&lt;code>mod&lt;/code>取模的结果.&lt;/p>
&lt;p>当然可以正常运行,结果为&lt;code>4&lt;/code>,如果我们将它换成引用捕获:&lt;/p>
&lt;div class="sourceCode" id="cb2">&lt;pre
class="sourceCode cpp">&lt;code class="sourceCode cpp">&lt;span id="cb2-1">&lt;a href="#cb2-1" aria-hidden="true" tabindex="-1">&lt;/a>&lt;span class="kw">auto&lt;/span> funtionTimesMod2&lt;span class="op">(&lt;/span>&lt;span class="dt">int&lt;/span> mod&lt;span class="op">)&lt;/span> &lt;span class="op">{&lt;/span>&lt;/span>
&lt;span id="cb2-2">&lt;a href="#cb2-2" aria-hidden="true" tabindex="-1">&lt;/a> &lt;span class="dt">int&lt;/span> variableA &lt;span class="op">=&lt;/span> mod&lt;span class="op">;&lt;/span>&lt;/span>
&lt;span id="cb2-3">&lt;a href="#cb2-3" aria-hidden="true" tabindex="-1">&lt;/a> &lt;span class="kw">auto&lt;/span> f &lt;span class="op">=&lt;/span> &lt;span class="op">[&amp;amp;&lt;/span>variableA&lt;span class="op">](&lt;/span>&lt;span class="dt">int&lt;/span> a&lt;span class="op">,&lt;/span> &lt;span class="dt">int&lt;/span> b&lt;span class="op">)&lt;/span> &lt;span class="op">{&lt;/span> &lt;span class="cf">return&lt;/span> a &lt;span class="op">%&lt;/span> variableA &lt;span class="op">*&lt;/span> b &lt;span class="op">%&lt;/span> variableA&lt;span class="op">;&lt;/span> &lt;span class="op">};&lt;/span>&lt;/span>
&lt;span id="cb2-4">&lt;a href="#cb2-4" aria-hidden="true" tabindex="-1">&lt;/a> &lt;span class="cf">return&lt;/span> f&lt;span class="op">;&lt;/span>&lt;/span>
&lt;span id="cb2-5">&lt;a href="#cb2-5" aria-hidden="true" tabindex="-1">&lt;/a>&lt;span class="op">}&lt;/span>&lt;/span>
&lt;span id="cb2-6">&lt;a href="#cb2-6" aria-hidden="true" tabindex="-1">&lt;/a>&lt;span class="dt">void&lt;/span> test2&lt;span class="op">()&lt;/span> &lt;span class="op">{&lt;/span>&lt;/span>
&lt;span id="cb2-7">&lt;a href="#cb2-7" aria-hidden="true" tabindex="-1">&lt;/a> cout &lt;span class="op">&amp;lt;&amp;lt;&lt;/span> &lt;span class="st">&amp;quot;---test2---&amp;quot;&lt;/span> &lt;span class="op">&amp;lt;&amp;lt;&lt;/span> endl&lt;span class="op">;&lt;/span>&lt;/span>
&lt;span id="cb2-8">&lt;a href="#cb2-8" aria-hidden="true" tabindex="-1">&lt;/a> &lt;span class="dt">int&lt;/span> a &lt;span class="op">=&lt;/span> &lt;span class="dv">10&lt;/span>&lt;span class="op">,&lt;/span> b &lt;span class="op">=&lt;/span> &lt;span class="dv">20&lt;/span>&lt;span class="op">,&lt;/span> c &lt;span class="op">=&lt;/span> &lt;span class="dv">7&lt;/span>&lt;span class="op">;&lt;/span>&lt;/span>
&lt;span id="cb2-9">&lt;a href="#cb2-9" aria-hidden="true" tabindex="-1">&lt;/a> &lt;span class="kw">auto&lt;/span> times &lt;span class="op">=&lt;/span> funtionTimesMod2&lt;span class="op">(&lt;/span>c&lt;span class="op">);&lt;/span>&lt;/span>
&lt;span id="cb2-10">&lt;a href="#cb2-10" aria-hidden="true" tabindex="-1">&lt;/a> cout &lt;span class="op">&amp;lt;&amp;lt;&lt;/span> times&lt;span class="op">(&lt;/span>a&lt;span class="op">,&lt;/span> b&lt;span class="op">)&lt;/span> &lt;span class="op">&amp;lt;&amp;lt;&lt;/span> endl&lt;span class="op">;&lt;/span>&lt;/span>
&lt;span id="cb2-11">&lt;a href="#cb2-11" aria-hidden="true" tabindex="-1">&lt;/a>&lt;span class="op">}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>这段代码就已经不能正常工作了,它的输出是 &lt;code>0&lt;/code>.&lt;/p></description></item><item><title>Shadowsocks (一) 主循环</title><link>https://blog.black-desk.cn/post/shadowsocks1/</link><pubDate>Sun, 10 Jul 2022 02:23:58 +0800</pubDate><guid>https://blog.black-desk.cn/post/shadowsocks1/</guid><description>&lt;p>这里简单分析一下Shadowsocks这个软件的源码.&lt;/p>
&lt;p>因为网上一直有声音认为其源码质量不错.刚好最近在学一些服务器编程相关的知识,所以就来简单分析一下它.&lt;/p>
&lt;p>同时由于希望能获得一些阅读源码的经验.
这里会简单记录我读源码的心路历程.&lt;/p>
&lt;h2 id="目录结构">目录结构&lt;/h2>
&lt;p>首先我们来tree一下,惯例,测试相关的文件就省略了&lt;/p>
&lt;pre>&lt;code>❯ tree
.
├── CHANGES
├── CONTRIBUTING.md
├── Dockerfile
├── LICENSE
├── MANIFEST.in
├── README.md
├── README.rst
├── config.json.example
├── debian
│   ├── changelog
│   ├── compat
│   ├── config.json
│   ├── control
│   ├── copyright
│   ├── docs
│   ├── init.d
│   ├── install
│   ├── rules
│   ├── shadowsocks.default
│   ├── shadowsocks.manpages
│   ├── source
│   │   └── format
│   ├── sslocal.1
│   └── ssserver.1
├── setup.py
├── shadowsocks
│   ├── __init__.py
│   ├── asyncdns.py
│   ├── common.py
│   ├── crypto
│   │   ├── __init__.py
│   │   ├── aead.py
│   │   ├── hkdf.py
│   │   ├── mbedtls.py
│   │   ├── openssl.py
│   │   ├── rc4_md5.py
│   │   ├── sodium.py
│   │   ├── table.py
│   │   └── util.py
│   ├── cryptor.py
│   ├── daemon.py
│   ├── eventloop.py
│   ├── local.py
│   ├── lru_cache.py
│   ├── manager.py
│   ├── server.py
│   ├── shell.py
│   ├── tcprelay.py
│   ├── tunnel.py
│   └── udprelay.py
├── snapcraft.yaml
├── tests
│   └── ...
└── utils
├── README.md
├── autoban.py
└── fail2ban
└── shadowsocks.conf
11 directories, 106 files&lt;/code>&lt;/pre>
&lt;p>可以看到,主要的源码应该都在shadowsocks目录下,我们可以看到用于加/解密的程序,可以看到处理TCP,UDP连接的程序.&lt;/p></description></item><item><title>记一个沙雕软件的破解</title><link>https://blog.black-desk.cn/post/overgrive/</link><pubDate>Sun, 10 Jul 2022 02:23:58 +0800</pubDate><guid>https://blog.black-desk.cn/post/overgrive/</guid><description>&lt;p>本文是一篇日记性质的碎碎念,唠叨和啰嗦在所难免,请见谅.&lt;/p>
&lt;p>故事是这样的,我突然想要一个能够在ubuntu上同步Google
Drive的软件.我需要这个软件能够监控我磁盘上的文件变化,一旦文件变化了就上传;当然Google
Drive上的文件要是发生了变化,也得能够同步到我的磁盘上.&lt;/p>
&lt;p>本来以为&lt;a
href="https://rclone.org/">RClone&lt;/a>可以,但是后来发现它只能单向同步,相当于是个备份工具,不能够满足我的要求.&lt;/p>
&lt;p>其实我也不希望搞那种很专业的工具,能有谷歌自己在Windows上做的那个"备份与同步"
那点功能,其实就可以了.配置最好也不要太麻烦.&lt;/p>
&lt;p>所以我找到了&lt;a
href="https://www.insynchq.com/">Insync&lt;/a>,这是一个支持OneDrive和Google
Drive的同步客户端.并不开源,而且售价有点高,要40刀.&lt;/p>
&lt;p>我暂时用不到OneDrive,而且这个钱说实话是不想花的(主要还是实在太贵了.&lt;/p>
&lt;p>于是我转头又找到了OverGrive,这是一个南非的网站(/组织?)搞的一个Google
Drive客户端,也不免费,但是只要5刀了,勉强可以接受.&lt;/p>
&lt;p>于是我拿出了我办的浦发双币visa卡.这张卡我办完了以后当时拿来尝试绑Google
Play没绑上,所以就一直没用上.不过不用公本费,也没有年金,更没有额度,我只能用支付宝,或者其他银行卡往里面存钱,之后才能消费美元.&lt;/p>
&lt;p>这下终于算是派上了用场.&lt;/p>
&lt;hr />
&lt;p>然后迎接我的就是付款失败.里面的钱明明够啊?为啥呢?&lt;/p>
&lt;p>打客服电话问了一下,说是这个商户被判定为有可能是投资目标之类的东西,所以被限制交易了.啊这(&lt;/p>
&lt;p>那没什么办法,我就淘宝上找了个paypal代付.&lt;/p>
&lt;p>结果24h过去了,我仍然没有从我的邮降收到我的激活码邮件,我非常确定没有在垃圾桶里.&lt;/p>
&lt;p>当然这个软件是有试用版的,有14天的试用期,可能是开发者认为只要14天以内发激活码就行了么???&lt;/p>
&lt;p>不过,由于这个软件存在一些启动过程中的问题,所以我稍微研究了一下它,发现这是一个
python写的东西,于是我用&lt;a
href="https://github.com/rocky/python-uncompyle6">uncompyle6&lt;/a>,给它反编译了一下,看到了源码.&lt;/p>
&lt;p>不过反编译出来的源码并不能正常运行,存在一些问题,应该是反编译的时候控制流识别出错了.&lt;/p>
&lt;p>但是我却因此能够看到它的激活流程:&lt;/p>
&lt;div class="sourceCode" id="cb1">&lt;pre
class="sourceCode python">&lt;code class="sourceCode python">&lt;span id="cb1-1">&lt;a href="#cb1-1" aria-hidden="true" tabindex="-1">&lt;/a>&lt;span class="kw">def&lt;/span> on_activation_button(widget):&lt;/span>
&lt;span id="cb1-2">&lt;a href="#cb1-2" aria-hidden="true" tabindex="-1">&lt;/a> &lt;span class="kw">global&lt;/span> licenseDisplay&lt;/span>
&lt;span id="cb1-3">&lt;a href="#cb1-3" aria-hidden="true" tabindex="-1">&lt;/a> &lt;span class="kw">global&lt;/span> splashProgressBar&lt;/span>
&lt;span id="cb1-4">&lt;a href="#cb1-4" aria-hidden="true" tabindex="-1">&lt;/a> &lt;span class="kw">global&lt;/span> splashWindow&lt;/span>
&lt;span id="cb1-5">&lt;a href="#cb1-5" aria-hidden="true" tabindex="-1">&lt;/a> &lt;span class="cf">if&lt;/span> &lt;span class="st">&amp;#39;ProgressBar&amp;#39;&lt;/span> &lt;span class="kw">in&lt;/span> &lt;span class="bu">str&lt;/span>(splashGrid.get_child_at(&lt;span class="dv">0&lt;/span>, &lt;span class="dv">4&lt;/span>)):&lt;/span>
&lt;span id="cb1-6">&lt;a href="#cb1-6" aria-hidden="true" tabindex="-1">&lt;/a> Gtk.Container.remove(splashGrid, splashProgressBar)&lt;/span>
&lt;span id="cb1-7">&lt;a href="#cb1-7" aria-hidden="true" tabindex="-1">&lt;/a> splashGrid.attach(splashEntry, &lt;span class="dv">0&lt;/span>, &lt;span class="dv">4&lt;/span>, &lt;span class="dv">2&lt;/span>, &lt;span class="dv">1&lt;/span>)&lt;/span>
&lt;span id="cb1-8">&lt;a href="#cb1-8" aria-hidden="true" tabindex="-1">&lt;/a> splashEntry.set_tooltip_text(_(&lt;span class="st">&amp;#39;Copy and Paste your&amp;#39;&lt;/span>) &lt;span class="op">+&lt;/span> &lt;span class="st">&amp;#39; &amp;#39;&lt;/span> &lt;span class="op">+&lt;/span> appDisplayName &lt;span class="op">+&lt;/span> &lt;span class="st">&amp;#39; &amp;#39;&lt;/span> &lt;span class="op">+&lt;/span> _(&lt;span class="st">&amp;#39;Activation code&amp;#39;&lt;/span>))&lt;/span>
&lt;span id="cb1-9">&lt;a href="#cb1-9" aria-hidden="true" tabindex="-1">&lt;/a> splashEntry.set_placeholder_text(_(&lt;span class="st">&amp;#39;Enter Activation Code&amp;#39;&lt;/span>))&lt;/span>
&lt;span id="cb1-10">&lt;a href="#cb1-10" aria-hidden="true" tabindex="-1">&lt;/a> splashLabel3.set_markup(&lt;span class="st">&amp;#39;&amp;lt;a href=&amp;quot;http://www.thefanclub.co.za/overgrive&amp;quot; &amp;gt;&amp;#39;&lt;/span> &lt;span class="op">+&lt;/span> _(&lt;span class="st">&amp;#39;Get Activation Code&amp;#39;&lt;/span>) &lt;span class="op">+&lt;/span> &lt;span class="st">&amp;#39;&amp;lt;/a&amp;gt;&amp;#39;&lt;/span>)&lt;/span>
&lt;span id="cb1-11">&lt;a href="#cb1-11" aria-hidden="true" tabindex="-1">&lt;/a> splashLabel3.&lt;span class="ex">connect&lt;/span>(&lt;span class="st">&amp;#39;activate-link&amp;#39;&lt;/span>, openInBrowserLisence, &lt;span class="st">&amp;#39;http://www.thefanclub.co.za/overgrive&amp;#39;&lt;/span>)&lt;/span>
&lt;span id="cb1-12">&lt;a href="#cb1-12" aria-hidden="true" tabindex="-1">&lt;/a> activationCode &lt;span class="op">=&lt;/span> splashEntry.get_text()&lt;/span>
&lt;span id="cb1-13">&lt;a href="#cb1-13" aria-hidden="true" tabindex="-1">&lt;/a> activationCode &lt;span class="op">=&lt;/span> activationCode.strip()&lt;/span>
&lt;span id="cb1-14">&lt;a href="#cb1-14" aria-hidden="true" tabindex="-1">&lt;/a> &lt;span class="cf">if&lt;/span> activationCode:&lt;/span>
&lt;span id="cb1-15">&lt;a href="#cb1-15" aria-hidden="true" tabindex="-1">&lt;/a> debugPrintAndLog(&lt;span class="st">&amp;#39;[SETUP] Activation Code : &amp;#39;&lt;/span> &lt;span class="op">+&lt;/span> activationCode)&lt;/span>
&lt;span id="cb1-16">&lt;a href="#cb1-16" aria-hidden="true" tabindex="-1">&lt;/a> &lt;span class="cf">if&lt;/span> activateLicense(activationCode):&lt;/span>
&lt;span id="cb1-17">&lt;a href="#cb1-17" aria-hidden="true" tabindex="-1">&lt;/a> licenseDisplay &lt;span class="op">=&lt;/span> _(&lt;span class="st">&amp;#39;License Activated&amp;#39;&lt;/span>)&lt;/span>
&lt;span id="cb1-18">&lt;a href="#cb1-18" aria-hidden="true" tabindex="-1">&lt;/a> splashWindow.destroy()&lt;/span>
&lt;span id="cb1-19">&lt;a href="#cb1-19" aria-hidden="true" tabindex="-1">&lt;/a> Gtk.main_quit()&lt;/span>
&lt;span id="cb1-20">&lt;a href="#cb1-20" aria-hidden="true" tabindex="-1">&lt;/a> &lt;span class="cf">else&lt;/span>:&lt;/span>
&lt;span id="cb1-21">&lt;a href="#cb1-21" aria-hidden="true" tabindex="-1">&lt;/a> splashEntry.set_text(&lt;span class="st">&amp;#39;&amp;#39;&lt;/span>)&lt;/span>
&lt;span id="cb1-22">&lt;a href="#cb1-22" aria-hidden="true" tabindex="-1">&lt;/a> splashEntry.set_placeholder_text(_(&lt;span class="st">&amp;#39;Activation Code&amp;#39;&lt;/span>) &lt;span class="op">+&lt;/span> &lt;span class="st">&amp;#39; &amp;#39;&lt;/span> &lt;span class="op">+&lt;/span> _(&lt;span class="st">&amp;#39;Error&amp;#39;&lt;/span>))&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>这里调用了&lt;code>activateLicense(activationCode)&lt;/code>来验证激活码;&lt;/p></description></item><item><title>麻将图片生成器</title><link>https://blog.black-desk.cn/post/mahjim/</link><pubDate>Sun, 10 Jul 2022 02:23:58 +0800</pubDate><guid>https://blog.black-desk.cn/post/mahjim/</guid><description>&lt;p>这两天由于拿到了一个麻将图包,运用了一些编译原理课上学的知识,动手实现了一个简单的麻将图片生成器.&lt;/p>
&lt;p>项目地址在&lt;a
href="https://github.com/black-desk/mahjim">这里&lt;/a>,同时也在自己的服务器上部署了一个&lt;a
href="https://mahjim.black-desk.cn">demo&lt;/a>.&lt;/p>
&lt;p>这里简单聊聊这个小工具.&lt;/p>
&lt;h2 id="名字">名字&lt;/h2>
&lt;p>Mahjong,是麻将这个游戏的一种英文表示方法,由于雀魂叫majsoul,这里就只用到j为止,加上图片image的im,就成了mahjim,
这个命名可以说是很没有新意了.&lt;/p>
&lt;h2 id="思路">思路&lt;/h2>
&lt;h3 id="基础">基础&lt;/h3>
&lt;p>首先要解决的就是如何用字符串表示麻将的问题.天凤有比较完整的&lt;a
href="https://tenhou.net/2/">记牌方式&lt;/a>:&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>m=萬子, p=筒子, s=索子, z=字牌, 0=赤&lt;/li>
&lt;li>一般形=４面子１雀頭 / 標準形=一般形＋七対形＋国士形&lt;/li>
&lt;li>ツモはその時点で使用していない牌をランダムに選択します&lt;/li>
&lt;li>有効牌をクリックすると打牌後にその牌をツモ牌として表示します&lt;/li>
&lt;li>(n*3+2)枚で開始：(n*3+2)枚目をツモ牌として表示&lt;/li>
&lt;li>(n*3+1)枚で開始：ツモはページのロード時に毎回変化&lt;/li>
&lt;li>和了役の判定はありません&lt;/li>
&lt;li>暗槓はできません&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>但是这套规则只是天风用来计算牌效的小程序使用的,并不能用来表示由于吃碰杠出现的牌横置情况.&lt;/p>
&lt;p>而且需要注意的是,天凤使用的这一套标记法,面对字牌并不那么方便,1~7z分别代表的是东南西北白发中,由于日麻和国内的三元牌顺序并不同,所以需要一定的适应.&lt;/p>
&lt;p>以这个为基础,我们可以考虑在牌前面加上前缀来表示牌的情况,实际上对于输出图片这个需求而言,任何一张麻将一共就4种状态,正常竖置,横置,横置加杠,翻面.其中翻面我们可以考虑直接输出一张背面的图片,所以可以看作是一种特殊的牌.如果采用&lt;code>_&lt;/code>来表示牌的横置,&lt;code>^&lt;/code>表示牌加杠,那么就形成了我采取的这种方法来表示一张正常的牌:&lt;/p>
&lt;pre>&lt;code>pre+num+class&lt;/code>&lt;/pre>
&lt;p>其中&lt;code>pre&lt;/code>表示一个前缀,可以是&lt;code>_&lt;/code>或者&lt;code>^&lt;/code>,也可以没有,用来表示牌的摆放方式.&lt;code>num&lt;/code>表示牌的点数,&lt;code>class&lt;/code>用来表示牌的种类,可以是&lt;code>p&lt;/code>,&lt;code>s&lt;/code>,&lt;code>m&lt;/code>,&lt;code>z&lt;/code>.&lt;/p>
&lt;p>但是每个牌都这么写就太烦了,我们需要一些简写的方式.&lt;/p>
&lt;p>很容易想到的就是class可以合并,比如&lt;code>123s&lt;/code>应该和&lt;code>1s2s3s&lt;/code>是等价的,这样也不会有什么歧义.&lt;/p>
&lt;h3 id="字牌">字牌&lt;/h3>
&lt;p>可以看出,这个记牌方式对于字牌来说非常不友好,而且按照上面的想法进行了缩写之后,国标的春夏秋冬梅兰竹菊加进来以后,字牌的总数会超过10种.那么这样的缩写就会有问题了.&lt;/p>
&lt;p>简单的解决方式就是直接用汉字来输入字牌,那么这样的话,类似中中中,白白白这种经常出现的组合又显得很不方便.所以我们也可以简单的想到一个这样的缩写:&lt;code>3中=中中中&lt;/code>,仔细想想就会发现这个缩写和之前的数字牌表示方式是不冲突的.&lt;/p>
&lt;h3 id="风格">风格&lt;/h3>
&lt;p>由于图包中的麻将区分国标和日麻,我们还需要一个额外的设置,来区分cn和jp,简单起见,我们就直接在整个字符串的开头放上一个&lt;code>cn|&lt;/code>或者&lt;code>jp|&lt;/code>来区分就可以了.&lt;/p>
&lt;h2 id="文法">文法&lt;/h2>
&lt;p>我们做了这样的设计之后,基本整理一下就可以得出文法了:&lt;/p>
&lt;pre>&lt;code>input -&amp;gt; style + &amp;quot;|&amp;quot; + majs | majs // 旧
input -&amp;gt; majs
style -&amp;gt; &amp;quot;cn&amp;quot; | &amp;quot;jp&amp;quot; 国标/日麻 // 旧
majs -&amp;gt; group + majs | empty 描述麻将牌的字符串
group -&amp;gt; ps + class | p + Z 按照牌的种类将牌分组, 比如 &amp;quot;123s456w3中&amp;quot; 有3个group, &amp;quot;123s&amp;quot; &amp;quot;456w&amp;quot; &amp;quot;3中&amp;quot;
F -&amp;gt; &amp;quot;东&amp;quot; | &amp;quot;南&amp;quot; | &amp;quot;西&amp;quot; | &amp;quot;北&amp;quot; | &amp;quot;白&amp;quot; | &amp;quot;发&amp;quot; | &amp;quot;中&amp;quot; | &amp;quot;+&amp;quot; | ... | empty 所有字牌, 其中 + 代表牌背
ps -&amp;gt; p + ps | empty 牌的列表
p -&amp;gt; pre + num
pre -&amp;gt; &amp;quot;_&amp;quot; | &amp;quot;^&amp;quot; | empty
num -&amp;gt; &amp;quot;0&amp;quot; | &amp;quot;1&amp;quot; | &amp;quot;2&amp;quot; | &amp;quot;3&amp;quot; | &amp;quot;4&amp;quot; | &amp;quot;5&amp;quot; | &amp;quot;6&amp;quot; | &amp;quot;7&amp;quot; | &amp;quot;8&amp;quot; | &amp;quot;9&amp;quot; | empty
class -&amp;gt; &amp;quot;p&amp;quot; | &amp;quot;s&amp;quot; | &amp;quot;w&amp;quot; | &amp;quot;z&amp;quot;&lt;/code>&lt;/pre>
&lt;h2 id="实现">实现&lt;/h2>
&lt;p>基本上得出了这样一个文法以后就可以直接去实现它了,我这里由于之前抄龙书附录A写过一个像是编译器前端的&lt;a
href="https://github.com/black-desk/Compiler-front-end">东西&lt;/a>,所以这里用了类似的结构来实现.&lt;/p></description></item><item><title>只是为了把 Steam 游戏放到开始屏幕上</title><link>https://blog.black-desk.cn/post/%E5%8F%AA%E6%98%AF%E4%B8%BA%E4%BA%86%E6%8A%8A-steam-%E6%B8%B8%E6%88%8F%E6%94%BE%E5%88%B0%E5%BC%80%E5%A7%8B%E5%B1%8F%E5%B9%95%E4%B8%8A/</link><pubDate>Sun, 10 Jul 2022 02:23:58 +0800</pubDate><guid>https://blog.black-desk.cn/post/%E5%8F%AA%E6%98%AF%E4%B8%BA%E4%BA%86%E6%8A%8A-steam-%E6%B8%B8%E6%88%8F%E6%94%BE%E5%88%B0%E5%BC%80%E5%A7%8B%E5%B1%8F%E5%B9%95%E4%B8%8A/</guid><description>&lt;p>很久以前, 我有一个梦想, 我的开始菜单上能直接固定一些 steam
游戏的磁贴.&lt;/p>
&lt;p>然后我苦苦地寻找, 发现了&lt;a
href="https://zhuanlan.zhihu.com/p/28416752">这篇&lt;/a>知乎文章,
然后我忍痛剁手, 花了我六块大洋, 买了这个叫 Steam Tiles 的 UWP 应用,
而这一切, 只是噩梦的开始.&lt;/p>
&lt;hr />
&lt;p>初次使用这个 UWP 应用, 它就刷新了我的三观.
一个功能如此简单的应用居然能这么卡.&lt;/p>
&lt;p>它需要读你安装 steam 游戏的目录,
然后从里面寻找合适大小的图片来制作磁贴, 也允许用户自定义图片, 可以从 url
下载图片, 可以从本地选取图片文件, 允许用户改变图片的位置, 大小,
以及磁贴的背景色.&lt;/p>
&lt;p>听起来很美好, 该自定义的都能自定义. 但是事实上.&lt;/p>
&lt;p>我是想破脑袋也想不出来, 为什么他读文件找图片能这么慢, 5个游戏,
他头一次找个图要将近半个小时.&lt;/p>
&lt;figure>
&lt;img src="https://i.loli.net/2020/05/04/gFqwyaEukvbALjJ.png"
alt="image-20200504214634198" />
&lt;figcaption aria-hidden="true">image-20200504214634198&lt;/figcaption>
&lt;/figure>
&lt;p>不仅慢, 还有可能会读不出图片来, 比如像下面这样:&lt;/p>
&lt;figure>
&lt;img src="https://i.loli.net/2020/05/04/xCsnIKF9TBfRwUt.png"
alt="image-20200504213156290" />
&lt;figcaption aria-hidden="true">image-20200504213156290&lt;/figcaption>
&lt;/figure>
&lt;p>而这个时候我唯一找到的解决方法, 就是 TMD 清除掉他对于图片的缓存,
然后再让他找一次.&lt;/p>
&lt;p>为什么这么慢呢? 我也不知道. 任务管理器开起来一看:&lt;/p>
&lt;figure>
&lt;img src="https://i.loli.net/2020/05/04/MKvWVlPTcQGzHOr.png"
alt="image-20200504213307798" />
&lt;figcaption aria-hidden="true">image-20200504213307798&lt;/figcaption>
&lt;/figure>
&lt;p>不占用 CPU, 内存也不大, 那是磁盘读写么?&lt;/p>
&lt;figure>
&lt;img src="https://i.loli.net/2020/05/04/eKTNusvSVZ3Co9m.png"
alt="image-20200504213452252" />
&lt;figcaption aria-hidden="true">image-20200504213452252&lt;/figcaption>
&lt;/figure>
&lt;p>看起来也不是磁盘读写.那咋回事呢? 天知道.&lt;/p>
&lt;p>好在这种找图的过程在你使用这个软件的过程中只会出现一次
(当然如果你装了个新游戏, 然后想把它钉在开始菜单里面,
你又会经历一遍这个神奇的事情.) 经过几次的尝试,
我终于可以正常的加载出图片了, 这个时候我发现了一个特别操蛋的事情.&lt;/p></description></item></channel></rss>