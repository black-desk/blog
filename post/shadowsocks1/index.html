<!doctype html><html lang=zh-cn dir=auto class=han-init>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Shadowsocks (一) 主循环 | RAMBLE&BB</title>
<meta name=keywords content>
<meta name=description content="这里简单分析一下Shadowsocks这个软件的源码.
因为网上一直有声音认为其源码质量不错.刚好最近在学一些服务器编程相关的知识,所以就来简单分析一下它.
同时由于希望能获得一些阅读源码的经验. 这里会简单记录我读源码的心路历程.
目录结构 首先我们来tree一下,惯例,测试相关的文件就省略了
❯ tree . ├── CHANGES ├── CONTRIBUTING.md ├── Dockerfile ├── LICENSE ├── MANIFEST.in ├── README.md ├── README.rst ├── config.json.example ├── debian │ ├── changelog │ ├── compat │ ├── config.json │ ├── control │ ├── copyright │ ├── docs │ ├── init.d │ ├── install │ ├── rules │ ├── shadowsocks.default │ ├── shadowsocks.manpages │ ├── source │ │ └── format │ ├── sslocal.1 │ └── ssserver.">
<meta name=author content>
<link rel=canonical href=https://blog.black-desk.cn/post/shadowsocks1/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.1953d0aedd677e6a027d5ea145d2e71a2b2101649fba37784de1035cf38994a3.css integrity="sha256-GVPQrt1nfmoCfV6hRdLnGishAWSfujd4TeEDXPOJlKM=" rel="preload stylesheet" as=style>
<link rel=icon href=https://blog.black-desk.cn/favicon.ico>
<link rel=apple-touch-icon href=https://blog.black-desk.cn/apple-touch-icon.png>
<meta name=twitter:title content="Shadowsocks (一) 主循环 | RAMBLE&BB">
<meta name=twitter:description content="这里简单分析一下Shadowsocks这个软件的源码.
因为网上一直有声音认为其源码质量不错.刚好最近在学一些服务器编程相关的知识,所以就来简单分析一下它.
同时由于希望能获得一些阅读源码的经验. 这里会简单记录我读源码的心路历程.
目录结构 首先我们来tree一下,惯例,测试相关的文件就省略了
❯ tree . ├── CHANGES ├── CONTRIBUTING.md ├── Dockerfile ├── LICENSE ├── MANIFEST.in ├── README.md ├── README.rst ├── config.json.example ├── debian │ ├── changelog │ ├── compat │ ├── config.json │ ├── control │ ├── copyright │ ├── docs │ ├── init.d │ ├── install │ ├── rules │ ├── shadowsocks.default │ ├── shadowsocks.manpages │ ├── source │ │ └── format │ ├── sslocal.1 │ └── ssserver.">
<meta name=twitter:site content="@novoreorx">
<meta name=twitter:creator content="@novoreorx">
<meta property="og:title" content="Shadowsocks (一) 主循环 | RAMBLE&BB">
<meta property="og:description" content="这里简单分析一下Shadowsocks这个软件的源码.
因为网上一直有声音认为其源码质量不错.刚好最近在学一些服务器编程相关的知识,所以就来简单分析一下它.
同时由于希望能获得一些阅读源码的经验. 这里会简单记录我读源码的心路历程.
目录结构 首先我们来tree一下,惯例,测试相关的文件就省略了
❯ tree . ├── CHANGES ├── CONTRIBUTING.md ├── Dockerfile ├── LICENSE ├── MANIFEST.in ├── README.md ├── README.rst ├── config.json.example ├── debian │ ├── changelog │ ├── compat │ ├── config.json │ ├── control │ ├── copyright │ ├── docs │ ├── init.d │ ├── install │ ├── rules │ ├── shadowsocks.default │ ├── shadowsocks.manpages │ ├── source │ │ └── format │ ├── sslocal.1 │ └── ssserver.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.black-desk.cn/post/shadowsocks1/">
<meta property="article:section" content="post">
<meta property="article:published_time" content="2022-07-10T02:23:58+08:00">
<meta property="article:modified_time" content="2022-07-10T02:23:58+08:00">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://blog.black-desk.cn/post/"},{"@type":"ListItem","position":3,"name":"Shadowsocks (一) 主循环","item":"https://blog.black-desk.cn/post/shadowsocks1/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Shadowsocks (一) 主循环 | RAMBLE\u0026BB","name":"Shadowsocks (一) 主循环","description":"这里简单分析一下Shadowsocks这个软件的源码.\n因为网上一直有声音认为其源码质量不错.刚好最近在学一些服务器编程相关的知识,所以就来简单分析一下它.\n同时由于希望能获得一些阅读源码的经验. 这里会简单记录我读源码的心路历程.\n目录结构 首先我们来tree一下,惯例,测试相关的文件就省略了\n❯ tree . ├── CHANGES ├── CONTRIBUTING.md ├── Dockerfile ├── LICENSE ├── MANIFEST.in ├── README.md ├── README.rst ├── config.json.example ├── debian │ ├── changelog │ ├── compat │ ├── config.json │ ├── control │ ├── copyright │ ├── docs │ ├── init.d │ ├── install │ ├── rules │ ├── shadowsocks.default │ ├── shadowsocks.manpages │ ├── source │ │ └── format │ ├── sslocal.1 │ └── ssserver.","keywords":[],"wordCount":"869","inLanguage":"zh-cn","datePublished":"2022-07-10T02:23:58+08:00","dateModified":"2022-07-10T02:23:58+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.black-desk.cn/post/shadowsocks1/"},"publisher":{"@type":"Organization","name":"RAMBLE\u0026BB","logo":{"@type":"ImageObject","url":"https://blog.black-desk.cn/favicon.ico"}}}</script><link rel=stylesheet media=all href=https://cdnjs.cloudflare.com/ajax/libs/Han/3.3.0/han.min.css>
<link rel=stylesheet media=all href=/pandoc_hl.css>
<style>.uri:only-child{display:inline-block;width:100%;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}input[type=checkbox]{margin-right:.2em;margin-left:-1.7em;width:1.5em}</style>
<script src=https://code.jquery.com/jquery-3.6.0.slim.min.js></script>
<script>$(document).ready(()=>{$(".uri:only-child").each(function(){(this.nextSibling&&this.nextSibling.nodeValue&&this.nextSibling.nodeValue.trim()||this.previousSibling&&this.previousSibling.nodeValue&&this.previousSibling.nodeValue.trim())&&$(this).css("display","inline").css("white-space","break-spaces")})})</script>
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary-bg:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
</head>
<body id=top><script data-no-instant>function switchTheme(a){switch(a){case'light':document.body.classList.remove('dark');break;case'dark':document.body.classList.add('dark');break;default:window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(a){switchTheme(a),localStorage.setItem("pref-theme",a)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=a=>{a?setPrefTheme('light'):setPrefTheme('dark')},window.addEventListener('toggle-theme',function(){const a=isDarkTheme();for(const b in toggleThemeCallbacks)toggleThemeCallbacks[b](a)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent('toggle-theme'))}</script>
<script>(function(){const b='light',a=getPrefTheme(),c=a||b;switchTheme(c)})()</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://blog.black-desk.cn accesskey=h title="RAMBLE&BB (Alt + H)">RAMBLE&BB</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
</ul>
</nav>
</header>
<main class="main post">
<article class=post-single>
<header class=post-header>
<div class=breadcrumbs><a href=https://blog.black-desk.cn>Home</a>&nbsp;»&nbsp;<a href=https://blog.black-desk.cn/post/>Posts</a></div>
<h1 class=post-title>
Shadowsocks (一) 主循环
</h1>
<div class=post-meta><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>July 10, 2022</span></span>
</div>
</header> <div class="toc side right">
<details open>
<summary accesskey=c title="(Alt + C)">
<span class=details>Table of Contents</span>
</summary>
<div class=inner><ul>
<li>
<a href=#%e7%9b%ae%e5%bd%95%e7%bb%93%e6%9e%84 aria-label=目录结构>目录结构</a></li>
<li>
<a href=#%e5%85%a5%e5%8f%a3 aria-label=入口>入口</a></li>
<li>
<a href=#%e5%ae%a2%e6%88%b7%e7%ab%af-sslocal aria-label="客户端 sslocal">客户端 sslocal</a><ul>
<li>
<a href=#main aria-label=main><code>main</code></a></li>
<li>
<a href=#looprun aria-label=loop.run><code>loop.run</code></a></li>
<li>
<a href=#tcprelay aria-label=TCPRelay><code>TCPRelay</code></a></li></ul>
</li>
<li>
<a href=#%e4%b8%bb%e8%a6%81%e6%b5%81%e7%a8%8b aria-label=主要流程>主要流程</a></li>
<li>
<a href=#%e9%97%ae%e9%a2%98 aria-label=问题>问题</a></li>
<li>
<a href=#%e9%81%97%e7%95%99%e9%97%ae%e9%a2%98 aria-label=遗留问题>遗留问题</a>
</li>
</ul>
</div>
</details>
</div>
<div class=post-content><p>这里简单分析一下Shadowsocks这个软件的源码.</p>
<p>因为网上一直有声音认为其源码质量不错.刚好最近在学一些服务器编程相关的知识,所以就来简单分析一下它.</p>
<p>同时由于希望能获得一些阅读源码的经验.
这里会简单记录我读源码的心路历程.</p>
<h2 id=目录结构>目录结构<a hidden class=anchor aria-hidden=true href=#目录结构>¶</a></h2>
<p>首先我们来tree一下,惯例,测试相关的文件就省略了</p>
<pre><code>❯ tree
.
├── CHANGES
├── CONTRIBUTING.md
├── Dockerfile
├── LICENSE
├── MANIFEST.in
├── README.md
├── README.rst
├── config.json.example
├── debian
│   ├── changelog
│   ├── compat
│   ├── config.json
│   ├── control
│   ├── copyright
│   ├── docs
│   ├── init.d
│   ├── install
│   ├── rules
│   ├── shadowsocks.default
│   ├── shadowsocks.manpages
│   ├── source
│   │   └── format
│   ├── sslocal.1
│   └── ssserver.1
├── setup.py
├── shadowsocks
│   ├── __init__.py
│   ├── asyncdns.py
│   ├── common.py
│   ├── crypto
│   │   ├── __init__.py
│   │   ├── aead.py
│   │   ├── hkdf.py
│   │   ├── mbedtls.py
│   │   ├── openssl.py
│   │   ├── rc4_md5.py
│   │   ├── sodium.py
│   │   ├── table.py
│   │   └── util.py
│   ├── cryptor.py
│   ├── daemon.py
│   ├── eventloop.py
│   ├── local.py
│   ├── lru_cache.py
│   ├── manager.py
│   ├── server.py
│   ├── shell.py
│   ├── tcprelay.py
│   ├── tunnel.py
│   └── udprelay.py
├── snapcraft.yaml
├── tests
│   └── ... 
└── utils
    ├── README.md
    ├── autoban.py
    └── fail2ban
        └── shadowsocks.conf

11 directories, 106 files</code></pre>
<p>可以看到,主要的源码应该都在shadowsocks目录下,我们可以看到用于加/解密的程序,可以看到处理TCP,UDP连接的程序.</p>
<p>也可以看到根目录下有DockerFile,以及一个不知道用来干啥的debain文件夹,我猜测是用来生成软件包的.</p>
<p>setup.py看起来像是用于安装成Python包的.</p>
<p>现在对于目录结构有一定认识和猜测了之后,我们可以开始下一步行动了.</p>
<h2 id=入口>入口<a hidden class=anchor aria-hidden=true href=#入口>¶</a></h2>
<p>阅读源码肯定要先找入口,至少要知道<code>main</code>在哪里,</p>
<p>由于实际上使用过这个软件,我知道我们在本地启动的时候输入的命令是<code>sslocal</code>,而在服务器运行的时候输入的命令是<code>ssserver</code>.</p>
<p>这意味着我们首先得知道这两个命令是如何启动代码的,输入这两个命令之后实际上运行了什么函数.</p>
<p>在<a href=https://github.com/shadowsocks/shadowsocks/blob/master/setup.py#L21><code>setup.py</code></a>中我们可以看到:</p>
<div class=sourceCode id=cb2><pre class="sourceCode python"><code class="sourceCode python"><span id=cb2-1><a href=#cb2-1 aria-hidden=true tabindex=-1></a>entry_points<span class=op>=</span><span class=st>&quot;&quot;&quot;</span></span>
<span id=cb2-2><a href=#cb2-2 aria-hidden=true tabindex=-1></a><span class=st>[console_scripts]</span></span>
<span id=cb2-3><a href=#cb2-3 aria-hidden=true tabindex=-1></a><span class=st>sslocal = shadowsocks.local:main</span></span>
<span id=cb2-4><a href=#cb2-4 aria-hidden=true tabindex=-1></a><span class=st>ssserver = shadowsocks.server:main</span></span>
<span id=cb2-5><a href=#cb2-5 aria-hidden=true tabindex=-1></a><span class=st>&quot;&quot;&quot;</span>,</span></code></pre></div>
<p>应该不难看出,上面的代码意味着:<code>sslocal</code>对应的是<code>shadowsocks</code>包下的<code>local.py</code>里面的<code>main()</code>,而<code>ssserver</code>对应的是<code>shadowsocks</code>包下的<code>server.py</code>里面的<code>main()</code>.</p>
<p>那么我们先看客户端,也就是<code>sslocal</code>.</p>
<h2 id=客户端-sslocal>客户端 sslocal<a hidden class=anchor aria-hidden=true href=#客户端-sslocal>¶</a></h2>
<h3 id=main><code>main</code><a hidden class=anchor aria-hidden=true href=#main>¶</a></h3>
<p><a href=https://github.com/shadowsocks/shadowsocks/blob/master/shadowsocks/local.py#L30><code>local.py::main</code></a>这个函数不长,我就直接复制过来了.</p>
<div class=sourceCode id=cb3><pre class="sourceCode python"><code class="sourceCode python"><span id=cb3-1><a href=#cb3-1 aria-hidden=true tabindex=-1></a><span class=at>@shell.exception_handle</span>(self_<span class=op>=</span><span class=va>False</span>, exit_code<span class=op>=</span><span class=dv>1</span>)</span>
<span id=cb3-2><a href=#cb3-2 aria-hidden=true tabindex=-1></a><span class=kw>def</span> main():</span>
<span id=cb3-3><a href=#cb3-3 aria-hidden=true tabindex=-1></a>    shell.check_python()</span>
<span id=cb3-4><a href=#cb3-4 aria-hidden=true tabindex=-1></a></span>
<span id=cb3-5><a href=#cb3-5 aria-hidden=true tabindex=-1></a>    <span class=co># fix py2exe</span></span>
<span id=cb3-6><a href=#cb3-6 aria-hidden=true tabindex=-1></a>    <span class=cf>if</span> <span class=bu>hasattr</span>(sys, <span class=st>&quot;frozen&quot;</span>) <span class=kw>and</span> sys.frozen <span class=kw>in</span> <span class=op>\</span></span>
<span id=cb3-7><a href=#cb3-7 aria-hidden=true tabindex=-1></a>            (<span class=st>&quot;windows_exe&quot;</span>, <span class=st>&quot;console_exe&quot;</span>):</span>
<span id=cb3-8><a href=#cb3-8 aria-hidden=true tabindex=-1></a>        p <span class=op>=</span> os.path.dirname(os.path.abspath(sys.executable))</span>
<span id=cb3-9><a href=#cb3-9 aria-hidden=true tabindex=-1></a>        os.chdir(p)</span>
<span id=cb3-10><a href=#cb3-10 aria-hidden=true tabindex=-1></a></span>
<span id=cb3-11><a href=#cb3-11 aria-hidden=true tabindex=-1></a>    config <span class=op>=</span> shell.get_config(<span class=va>True</span>) <span class=co># shell大约是一个&quot;外壳&quot;,用来交互.所以我们使用shell来获得配置文件.</span></span>
<span id=cb3-12><a href=#cb3-12 aria-hidden=true tabindex=-1></a>    daemon.daemon_exec(config) <span class=co># 启动daemon进程</span></span>
<span id=cb3-13><a href=#cb3-13 aria-hidden=true tabindex=-1></a></span>
<span id=cb3-14><a href=#cb3-14 aria-hidden=true tabindex=-1></a>    logging.info(<span class=st>&quot;starting local at </span><span class=sc>%s</span><span class=st>:</span><span class=sc>%d</span><span class=st>&quot;</span> <span class=op>%</span></span>
<span id=cb3-15><a href=#cb3-15 aria-hidden=true tabindex=-1></a>                 (config[<span class=st>&#39;local_address&#39;</span>], config[<span class=st>&#39;local_port&#39;</span>])) <span class=co># 可以看出来监听的地址和端口是写在配置文件里的.</span></span>
<span id=cb3-16><a href=#cb3-16 aria-hidden=true tabindex=-1></a></span>
<span id=cb3-17><a href=#cb3-17 aria-hidden=true tabindex=-1></a>    dns_resolver <span class=op>=</span> asyncdns.DNSResolver() <span class=co># 启动dns,这个dns貌似是不可配置的,因为config没有被传入. </span></span>
<span id=cb3-18><a href=#cb3-18 aria-hidden=true tabindex=-1></a>    tcp_server <span class=op>=</span> tcprelay.TCPRelay(config, dns_resolver, <span class=va>True</span>) <span class=co># 创建新的tcp_server和udp_server</span></span>
<span id=cb3-19><a href=#cb3-19 aria-hidden=true tabindex=-1></a>    udp_server <span class=op>=</span> udprelay.UDPRelay(config, dns_resolver, <span class=va>True</span>)</span>
<span id=cb3-20><a href=#cb3-20 aria-hidden=true tabindex=-1></a>    loop <span class=op>=</span> eventloop.EventLoop()</span>
<span id=cb3-21><a href=#cb3-21 aria-hidden=true tabindex=-1></a>    dns_resolver.add_to_loop(loop)</span>
<span id=cb3-22><a href=#cb3-22 aria-hidden=true tabindex=-1></a>    tcp_server.add_to_loop(loop)</span>
<span id=cb3-23><a href=#cb3-23 aria-hidden=true tabindex=-1></a>    udp_server.add_to_loop(loop) <span class=co># 建立一个loop将dns/udp/tcp server都添加到这个loop中.</span></span>
<span id=cb3-24><a href=#cb3-24 aria-hidden=true tabindex=-1></a></span>
<span id=cb3-25><a href=#cb3-25 aria-hidden=true tabindex=-1></a>    <span class=kw>def</span> handler(signum, _):</span>
<span id=cb3-26><a href=#cb3-26 aria-hidden=true tabindex=-1></a>        logging.warn(<span class=st>&#39;received SIGQUIT, doing graceful shutting down..&#39;</span>)</span>
<span id=cb3-27><a href=#cb3-27 aria-hidden=true tabindex=-1></a>        tcp_server.close(next_tick<span class=op>=</span><span class=va>True</span>)</span>
<span id=cb3-28><a href=#cb3-28 aria-hidden=true tabindex=-1></a>        udp_server.close(next_tick<span class=op>=</span><span class=va>True</span>)</span>
<span id=cb3-29><a href=#cb3-29 aria-hidden=true tabindex=-1></a>    signal.signal(<span class=bu>getattr</span>(signal, <span class=st>&#39;SIGQUIT&#39;</span>, signal.SIGTERM), handler) <span class=co># 注册信号处理函数.</span></span>
<span id=cb3-30><a href=#cb3-30 aria-hidden=true tabindex=-1></a></span>
<span id=cb3-31><a href=#cb3-31 aria-hidden=true tabindex=-1></a>    <span class=kw>def</span> int_handler(signum, _):</span>
<span id=cb3-32><a href=#cb3-32 aria-hidden=true tabindex=-1></a>        sys.exit(<span class=dv>1</span>)</span>
<span id=cb3-33><a href=#cb3-33 aria-hidden=true tabindex=-1></a>    signal.signal(signal.SIGINT, int_handler) <span class=co># 注册信号处理函数.</span></span>
<span id=cb3-34><a href=#cb3-34 aria-hidden=true tabindex=-1></a></span>
<span id=cb3-35><a href=#cb3-35 aria-hidden=true tabindex=-1></a>    daemon.set_user(config.get(<span class=st>&#39;user&#39;</span>, <span class=va>None</span>))</span>
<span id=cb3-36><a href=#cb3-36 aria-hidden=true tabindex=-1></a>    loop.run() <span class=co># 启动</span></span></code></pre></div>
<p><a href=https://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html>这里</a>有关于两个信号<code>SIGQUIT</code>和<code>SIGINT</code>的区别.</p>
<p>这里可以记下这么几个问题:</p>
<ol type=1>
<li>daemon进程是怎么启动的呢?为什么要等最后<code>loop.run()</code>之前再<code>set_user</code>呢?</li>
<li>为什么dns服务器创建时不读取配置文件?</li>
<li><code>loop</code>是怎么工作的?</li>
<li>三个<code>..._server</code>分别是怎么工作的呢?</li>
</ol>
<p>可以很明显地看出,我们的主要目标应该是3和4.</p>
<p>那么接下来的目标就是<code>loop.run()</code>了.</p>
<h3 id=looprun><code>loop.run</code><a hidden class=anchor aria-hidden=true href=#looprun>¶</a></h3>
<p>看一个类的时候我们可以先看它是如何工作的.有什么看不懂的地方再回头看它的构造函数之类的东西.</p>
<p>对于一个过程其实也是一样的.我们可以先看它是如何工作的,然后再看它是怎么初始化的.</p>
<p>落实到这里,就是说我们可以先看<code>run()</code>看不懂了再去看<code>add_to_loop()</code></p>
<p>看看<a href=https://github.com/shadowsocks/shadowsocks/blob/master/shadowsocks/eventloop.py#L193><code>eventloop.py:run()</code></a></p>
<div class=sourceCode id=cb4><pre class="sourceCode python"><code class="sourceCode python"><span id=cb4-1><a href=#cb4-1 aria-hidden=true tabindex=-1></a><span class=kw>def</span> run(<span class=va>self</span>):</span>
<span id=cb4-2><a href=#cb4-2 aria-hidden=true tabindex=-1></a>    events <span class=op>=</span> []</span>
<span id=cb4-3><a href=#cb4-3 aria-hidden=true tabindex=-1></a>    <span class=cf>while</span> <span class=kw>not</span> <span class=va>self</span>._stopping:</span>
<span id=cb4-4><a href=#cb4-4 aria-hidden=true tabindex=-1></a>        asap <span class=op>=</span> <span class=va>False</span></span>
<span id=cb4-5><a href=#cb4-5 aria-hidden=true tabindex=-1></a>        <span class=cf>try</span>:</span>
<span id=cb4-6><a href=#cb4-6 aria-hidden=true tabindex=-1></a>            events <span class=op>=</span> <span class=va>self</span>.poll(TIMEOUT_PRECISION) <span class=co># poll 出一个 events, 从下面看 events 中有 sock, fd 和 event 这三个东西.</span></span>
<span id=cb4-7><a href=#cb4-7 aria-hidden=true tabindex=-1></a>        <span class=cf>except</span> (<span class=pp>OSError</span>, <span class=pp>IOError</span>) <span class=im>as</span> e:</span>
<span id=cb4-8><a href=#cb4-8 aria-hidden=true tabindex=-1></a>            <span class=cf>if</span> errno_from_exception(e) <span class=kw>in</span> (errno.EPIPE, errno.EINTR):</span>
<span id=cb4-9><a href=#cb4-9 aria-hidden=true tabindex=-1></a>                <span class=co># EPIPE: Happens when the client closes the connection</span></span>
<span id=cb4-10><a href=#cb4-10 aria-hidden=true tabindex=-1></a>                <span class=co># EINTR: Happens when received a signal</span></span>
<span id=cb4-11><a href=#cb4-11 aria-hidden=true tabindex=-1></a>                <span class=co># handles them as soon as possible</span></span>
<span id=cb4-12><a href=#cb4-12 aria-hidden=true tabindex=-1></a>                asap <span class=op>=</span> <span class=va>True</span></span>
<span id=cb4-13><a href=#cb4-13 aria-hidden=true tabindex=-1></a>                logging.debug(<span class=st>&#39;poll:</span><span class=sc>%s</span><span class=st>&#39;</span>, e)</span>
<span id=cb4-14><a href=#cb4-14 aria-hidden=true tabindex=-1></a>            <span class=cf>else</span>:</span>
<span id=cb4-15><a href=#cb4-15 aria-hidden=true tabindex=-1></a>                logging.error(<span class=st>&#39;poll:</span><span class=sc>%s</span><span class=st>&#39;</span>, e)</span>
<span id=cb4-16><a href=#cb4-16 aria-hidden=true tabindex=-1></a>                traceback.print_exc()</span>
<span id=cb4-17><a href=#cb4-17 aria-hidden=true tabindex=-1></a>                <span class=cf>continue</span></span>
<span id=cb4-18><a href=#cb4-18 aria-hidden=true tabindex=-1></a></span>
<span id=cb4-19><a href=#cb4-19 aria-hidden=true tabindex=-1></a>        <span class=cf>for</span> sock, fd, event <span class=kw>in</span> events:</span>
<span id=cb4-20><a href=#cb4-20 aria-hidden=true tabindex=-1></a>            handler <span class=op>=</span> <span class=va>self</span>._fdmap.get(fd, <span class=va>None</span>) <span class=co># 获得和 fd 对应的 handler</span></span>
<span id=cb4-21><a href=#cb4-21 aria-hidden=true tabindex=-1></a>            <span class=cf>if</span> handler <span class=kw>is</span> <span class=kw>not</span> <span class=va>None</span>:</span>
<span id=cb4-22><a href=#cb4-22 aria-hidden=true tabindex=-1></a>                handler <span class=op>=</span> handler[<span class=dv>1</span>]</span>
<span id=cb4-23><a href=#cb4-23 aria-hidden=true tabindex=-1></a>                <span class=cf>try</span>:</span>
<span id=cb4-24><a href=#cb4-24 aria-hidden=true tabindex=-1></a>                    handler.handle_event(sock, fd, event) <span class=co># 调用 handler 处理 IO 事件.</span></span>
<span id=cb4-25><a href=#cb4-25 aria-hidden=true tabindex=-1></a>                <span class=cf>except</span> (<span class=pp>OSError</span>, <span class=pp>IOError</span>) <span class=im>as</span> e:</span>
<span id=cb4-26><a href=#cb4-26 aria-hidden=true tabindex=-1></a>                    shell.print_exception(e)</span>
<span id=cb4-27><a href=#cb4-27 aria-hidden=true tabindex=-1></a>        now <span class=op>=</span> time.time()</span>
<span id=cb4-28><a href=#cb4-28 aria-hidden=true tabindex=-1></a>        <span class=cf>if</span> asap <span class=kw>or</span> now <span class=op>-</span> <span class=va>self</span>._last_time <span class=op>&gt;=</span> TIMEOUT_PRECISION:</span>
<span id=cb4-29><a href=#cb4-29 aria-hidden=true tabindex=-1></a>            <span class=cf>for</span> callback <span class=kw>in</span> <span class=va>self</span>._periodic_callbacks:</span>
<span id=cb4-30><a href=#cb4-30 aria-hidden=true tabindex=-1></a>                callback()</span>
<span id=cb4-31><a href=#cb4-31 aria-hidden=true tabindex=-1></a>            <span class=va>self</span>._last_time <span class=op>=</span> now</span></code></pre></div>
<p>大致上这个loop的工作流程就是:</p>
<p>poll出来一个IO事件,看下这个socket有没有对应的handler,有就去调这个handler.</p>
<p>这里扩充一下问题列表:</p>
<ol type=1>
<li>daemon进程是怎么启动的呢?为什么要等最后<code>loop.run()</code>之前再<code>set_uesr</code>呢?</li>
<li>为什么dns服务器创建时不读取配置文件?</li>
<li><code>loop</code>是怎么工作的?
<ol type=1>
<li><p>handler这个对象是如何注册到loop中的?[是在什么地方被放进<code>_fdmap</code>的呢?]</p></li>
<li><p><code>handler[1]</code>?</p></li>
<li><p>为什么还需要判断<code>handler</code>不为空,什么情况下它会是空呢?</p></li>
<li><p>为什么<code>events</code>遍历的时候会出来<code>sock</code>,<code>fd</code>和<code>event</code>三个变量呢?<code>epoll</code>不是只会有<code>fd</code>和<code>event</code>两个东西告诉程序是哪个文件发生了什么样的事件吗?</p></li>
<li><p>最后看起来是在判断超时的几行代码的意义是什么呢?</p></li>
</ol></li>
<li>三个server分别是怎么工作的呢?</li>
</ol>
<p>那么重点应该是3.1,我们可以猜测这个注册发生在<code>add_to_loop</code>里面.但是我们首先可以发现loop有个方法叫add,这里写了<code>_fdmap</code>.</p>
<p><a href=https://github.com/shadowsocks/shadowsocks/blob/master/shadowsocks/eventloop.py#L170><code>eventloop.py:add()</code></a></p>
<div class=sourceCode id=cb5><pre class="sourceCode python"><code class="sourceCode python"><span id=cb5-1><a href=#cb5-1 aria-hidden=true tabindex=-1></a><span class=kw>def</span> add(<span class=va>self</span>, f, mode, handler):</span>
<span id=cb5-2><a href=#cb5-2 aria-hidden=true tabindex=-1></a>    fd <span class=op>=</span> f.fileno()</span>
<span id=cb5-3><a href=#cb5-3 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._fdmap[fd] <span class=op>=</span> (f, handler)</span>
<span id=cb5-4><a href=#cb5-4 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._impl.register(fd, mode)</span></code></pre></div>
<p>这里有一个注册函数.</p>
<p>在<a href=https://github.com/shadowsocks/shadowsocks/blob/master/shadowsocks/eventloop.py#L147><code>eventloop.py::__init__()</code></a>中可以看到:我们的<code>_impl</code>就是<code>select.epoll</code>.</p>
<p>那么我们现在可以看看是谁在调用这个<code>add</code>,以<code>TCPRelay</code>的<code>add_to_loop</code>为例:</p>
<h3 id=tcprelay><code>TCPRelay</code><a hidden class=anchor aria-hidden=true href=#tcprelay>¶</a></h3>
<p>在<a href=https://github.com/shadowsocks/shadowsocks/blob/master/shadowsocks/tcprelay.py#L766>这里</a>可以看到</p>
<div class=sourceCode id=cb6><pre class="sourceCode python"><code class="sourceCode python"><span id=cb6-1><a href=#cb6-1 aria-hidden=true tabindex=-1></a><span class=kw>def</span> add_to_loop(<span class=va>self</span>, loop):</span>
<span id=cb6-2><a href=#cb6-2 aria-hidden=true tabindex=-1></a>    <span class=cf>if</span> <span class=va>self</span>._eventloop:</span>
<span id=cb6-3><a href=#cb6-3 aria-hidden=true tabindex=-1></a>        <span class=cf>raise</span> <span class=pp>Exception</span>(<span class=st>&#39;already add to loop&#39;</span>)</span>
<span id=cb6-4><a href=#cb6-4 aria-hidden=true tabindex=-1></a>    <span class=cf>if</span> <span class=va>self</span>._closed:</span>
<span id=cb6-5><a href=#cb6-5 aria-hidden=true tabindex=-1></a>        <span class=cf>raise</span> <span class=pp>Exception</span>(<span class=st>&#39;already closed&#39;</span>)</span>
<span id=cb6-6><a href=#cb6-6 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._eventloop <span class=op>=</span> loop</span>
<span id=cb6-7><a href=#cb6-7 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._eventloop.add(<span class=va>self</span>._server_socket,</span>
<span id=cb6-8><a href=#cb6-8 aria-hidden=true tabindex=-1></a>                        eventloop.POLL_IN <span class=op>|</span> eventloop.POLL_ERR, <span class=va>self</span>)</span>
<span id=cb6-9><a href=#cb6-9 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._eventloop.add_periodic(<span class=va>self</span>.handle_periodic)</span></code></pre></div>
<p>这里将自己的<code>_server_socket</code>注册给了<code>loop</code>,这个<code>socket</code>肯定是创建<code>TCPRelay</code>的时候建立的.</p>
<p>我们来看看这个创建过程:</p>
<p>在<a href=https://github.com/shadowsocks/shadowsocks/blob/master/shadowsocks/tcprelay.py#L723>这里</a>
我们可以看到:</p>
<div class=sourceCode id=cb7><pre class="sourceCode python"><code class="sourceCode python"><span id=cb7-1><a href=#cb7-1 aria-hidden=true tabindex=-1></a><span class=kw>def</span> <span class=fu>__init__</span>(<span class=va>self</span>, config, dns_resolver, is_local, stat_callback<span class=op>=</span><span class=va>None</span>):</span>
<span id=cb7-2><a href=#cb7-2 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._config <span class=op>=</span> config</span>
<span id=cb7-3><a href=#cb7-3 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._is_local <span class=op>=</span> is_local</span>
<span id=cb7-4><a href=#cb7-4 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._dns_resolver <span class=op>=</span> dns_resolver</span>
<span id=cb7-5><a href=#cb7-5 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._closed <span class=op>=</span> <span class=va>False</span></span>
<span id=cb7-6><a href=#cb7-6 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._eventloop <span class=op>=</span> <span class=va>None</span></span>
<span id=cb7-7><a href=#cb7-7 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._fd_to_handlers <span class=op>=</span> {}</span>
<span id=cb7-8><a href=#cb7-8 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._is_tunnel <span class=op>=</span> <span class=va>False</span></span>
<span id=cb7-9><a href=#cb7-9 aria-hidden=true tabindex=-1></a></span>
<span id=cb7-10><a href=#cb7-10 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._timeout <span class=op>=</span> config[<span class=st>&#39;timeout&#39;</span>]</span>
<span id=cb7-11><a href=#cb7-11 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._timeouts <span class=op>=</span> []  <span class=co># a list for all the handlers</span></span>
<span id=cb7-12><a href=#cb7-12 aria-hidden=true tabindex=-1></a>    <span class=co># we trim the timeouts once a while</span></span>
<span id=cb7-13><a href=#cb7-13 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._timeout_offset <span class=op>=</span> <span class=dv>0</span>   <span class=co># last checked position for timeout</span></span>
<span id=cb7-14><a href=#cb7-14 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._handler_to_timeouts <span class=op>=</span> {}  <span class=co># key: handler value: index in timeouts</span></span>
<span id=cb7-15><a href=#cb7-15 aria-hidden=true tabindex=-1></a></span>
<span id=cb7-16><a href=#cb7-16 aria-hidden=true tabindex=-1></a>    <span class=cf>if</span> is_local:</span>
<span id=cb7-17><a href=#cb7-17 aria-hidden=true tabindex=-1></a>        listen_addr <span class=op>=</span> config[<span class=st>&#39;local_address&#39;</span>]</span>
<span id=cb7-18><a href=#cb7-18 aria-hidden=true tabindex=-1></a>        listen_port <span class=op>=</span> config[<span class=st>&#39;local_port&#39;</span>]</span>
<span id=cb7-19><a href=#cb7-19 aria-hidden=true tabindex=-1></a>    <span class=cf>else</span>:</span>
<span id=cb7-20><a href=#cb7-20 aria-hidden=true tabindex=-1></a>        listen_addr <span class=op>=</span> config[<span class=st>&#39;server&#39;</span>]</span>
<span id=cb7-21><a href=#cb7-21 aria-hidden=true tabindex=-1></a>        listen_port <span class=op>=</span> config[<span class=st>&#39;server_port&#39;</span>]</span>
<span id=cb7-22><a href=#cb7-22 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._listen_port <span class=op>=</span> listen_port</span>
<span id=cb7-23><a href=#cb7-23 aria-hidden=true tabindex=-1></a></span>
<span id=cb7-24><a href=#cb7-24 aria-hidden=true tabindex=-1></a>    addrs <span class=op>=</span> socket.getaddrinfo(listen_addr, listen_port, <span class=dv>0</span>,</span>
<span id=cb7-25><a href=#cb7-25 aria-hidden=true tabindex=-1></a>                               socket.SOCK_STREAM, socket.SOL_TCP)</span>
<span id=cb7-26><a href=#cb7-26 aria-hidden=true tabindex=-1></a>    <span class=cf>if</span> <span class=bu>len</span>(addrs) <span class=op>==</span> <span class=dv>0</span>:</span>
<span id=cb7-27><a href=#cb7-27 aria-hidden=true tabindex=-1></a>        <span class=cf>raise</span> <span class=pp>Exception</span>(<span class=st>&quot;can&#39;t get addrinfo for </span><span class=sc>%s</span><span class=st>:</span><span class=sc>%d</span><span class=st>&quot;</span> <span class=op>%</span></span>
<span id=cb7-28><a href=#cb7-28 aria-hidden=true tabindex=-1></a>                        (listen_addr, listen_port))</span>
<span id=cb7-29><a href=#cb7-29 aria-hidden=true tabindex=-1></a>    af, socktype, proto, canonname, sa <span class=op>=</span> addrs[<span class=dv>0</span>]</span>
<span id=cb7-30><a href=#cb7-30 aria-hidden=true tabindex=-1></a>    server_socket <span class=op>=</span> socket.socket(af, socktype, proto)</span>
<span id=cb7-31><a href=#cb7-31 aria-hidden=true tabindex=-1></a>    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class=dv>1</span>)</span>
<span id=cb7-32><a href=#cb7-32 aria-hidden=true tabindex=-1></a>    server_socket.bind(sa)</span>
<span id=cb7-33><a href=#cb7-33 aria-hidden=true tabindex=-1></a>    server_socket.setblocking(<span class=va>False</span>)</span>
<span id=cb7-34><a href=#cb7-34 aria-hidden=true tabindex=-1></a>    <span class=cf>if</span> config[<span class=st>&#39;fast_open&#39;</span>]:</span>
<span id=cb7-35><a href=#cb7-35 aria-hidden=true tabindex=-1></a>        <span class=cf>try</span>:</span>
<span id=cb7-36><a href=#cb7-36 aria-hidden=true tabindex=-1></a>            server_socket.setsockopt(socket.SOL_TCP, <span class=dv>23</span>, <span class=dv>5</span>)</span>
<span id=cb7-37><a href=#cb7-37 aria-hidden=true tabindex=-1></a>        <span class=cf>except</span> socket.error:</span>
<span id=cb7-38><a href=#cb7-38 aria-hidden=true tabindex=-1></a>            logging.error(<span class=st>&#39;warning: fast open is not available&#39;</span>)</span>
<span id=cb7-39><a href=#cb7-39 aria-hidden=true tabindex=-1></a>            <span class=va>self</span>._config[<span class=st>&#39;fast_open&#39;</span>] <span class=op>=</span> <span class=va>False</span></span>
<span id=cb7-40><a href=#cb7-40 aria-hidden=true tabindex=-1></a>    server_socket.listen(<span class=dv>1024</span>)</span>
<span id=cb7-41><a href=#cb7-41 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._server_socket <span class=op>=</span> server_socket</span>
<span id=cb7-42><a href=#cb7-42 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._stat_callback <span class=op>=</span> stat_callback</span></code></pre></div>
<p>这就是创建socket,bind,listen的三部曲了.这里还能看到一个Fast
Open的设置.</p>
<p>使用了非阻塞的 socket.</p>
<p>接下来的问题就是:</p>
<div class=sourceCode id=cb8><pre class="sourceCode python"><code class="sourceCode python"><span id=cb8-1><a href=#cb8-1 aria-hidden=true tabindex=-1></a><span class=va>self</span>._eventloop.add(<span class=va>self</span>._server_socket,</span>
<span id=cb8-2><a href=#cb8-2 aria-hidden=true tabindex=-1></a>                        eventloop.POLL_IN <span class=op>|</span> eventloop.POLL_ERR, <span class=va>self</span>)</span></code></pre></div>
<p>这个地方,向<code>_eventloop</code>注册事件的时候,实际上添加进去的handle是self.</p>
<p>在上面这里的<a href=https://github.com/shadowsocks/shadowsocks/blob/master/shadowsocks/eventloop.py#L193><code>eventloop.py:run()</code></a>中:</p>
<div class=sourceCode id=cb9><pre class="sourceCode python"><code class="sourceCode python"><span id=cb9-1><a href=#cb9-1 aria-hidden=true tabindex=-1></a>...</span>
<span id=cb9-2><a href=#cb9-2 aria-hidden=true tabindex=-1></a>        <span class=cf>for</span> sock, fd, event <span class=kw>in</span> events:</span>
<span id=cb9-3><a href=#cb9-3 aria-hidden=true tabindex=-1></a>            handler <span class=op>=</span> <span class=va>self</span>._fdmap.get(fd, <span class=va>None</span>) <span class=co># 获得和fd对应的handler</span></span>
<span id=cb9-4><a href=#cb9-4 aria-hidden=true tabindex=-1></a>            <span class=cf>if</span> handler <span class=kw>is</span> <span class=kw>not</span> <span class=va>None</span>:</span>
<span id=cb9-5><a href=#cb9-5 aria-hidden=true tabindex=-1></a>                handler <span class=op>=</span> handler[<span class=dv>1</span>]</span>
<span id=cb9-6><a href=#cb9-6 aria-hidden=true tabindex=-1></a>                <span class=cf>try</span>:</span>
<span id=cb9-7><a href=#cb9-7 aria-hidden=true tabindex=-1></a>                    handler.handle_event(sock, fd, event) <span class=co># 调用handler处理IO事件.</span></span>
<span id=cb9-8><a href=#cb9-8 aria-hidden=true tabindex=-1></a>                <span class=cf>except</span> (<span class=pp>OSError</span>, <span class=pp>IOError</span>) <span class=im>as</span> e:</span>
<span id=cb9-9><a href=#cb9-9 aria-hidden=true tabindex=-1></a>                    shell.print_exception(e)</span>
<span id=cb9-10><a href=#cb9-10 aria-hidden=true tabindex=-1></a>...</span></code></pre></div>
<p>调用了<code>handle_event()</code>方法,那我们来看一下</p>
<p><a href=https://github.com/shadowsocks/shadowsocks/blob/master/shadowsocks/tcprelay.py#L835>这里</a></p>
<div class=sourceCode id=cb10><pre class="sourceCode python"><code class="sourceCode python"><span id=cb10-1><a href=#cb10-1 aria-hidden=true tabindex=-1></a>    <span class=kw>def</span> handle_event(<span class=va>self</span>, sock, fd, event):</span>
<span id=cb10-2><a href=#cb10-2 aria-hidden=true tabindex=-1></a>        <span class=co># handle events and dispatch to handlers</span></span>
<span id=cb10-3><a href=#cb10-3 aria-hidden=true tabindex=-1></a>        <span class=cf>if</span> sock:</span>
<span id=cb10-4><a href=#cb10-4 aria-hidden=true tabindex=-1></a>            logging.log(shell.VERBOSE_LEVEL, <span class=st>&#39;fd </span><span class=sc>%d</span><span class=st> </span><span class=sc>%s</span><span class=st>&#39;</span>, fd,</span>
<span id=cb10-5><a href=#cb10-5 aria-hidden=true tabindex=-1></a>                        eventloop.EVENT_NAMES.get(event, event))</span>
<span id=cb10-6><a href=#cb10-6 aria-hidden=true tabindex=-1></a>        <span class=cf>if</span> sock <span class=op>==</span> <span class=va>self</span>._server_socket: <span class=co># 如果是监听新连接的socket</span></span>
<span id=cb10-7><a href=#cb10-7 aria-hidden=true tabindex=-1></a>            <span class=cf>if</span> event <span class=op>&amp;</span> eventloop.POLL_ERR:</span>
<span id=cb10-8><a href=#cb10-8 aria-hidden=true tabindex=-1></a>                <span class=co># </span><span class=al>TODO</span></span>
<span id=cb10-9><a href=#cb10-9 aria-hidden=true tabindex=-1></a>                <span class=cf>raise</span> <span class=pp>Exception</span>(<span class=st>&#39;server_socket error&#39;</span>)</span>
<span id=cb10-10><a href=#cb10-10 aria-hidden=true tabindex=-1></a>            <span class=cf>try</span>:</span>
<span id=cb10-11><a href=#cb10-11 aria-hidden=true tabindex=-1></a>                logging.debug(<span class=st>&#39;accept&#39;</span>)</span>
<span id=cb10-12><a href=#cb10-12 aria-hidden=true tabindex=-1></a>                conn <span class=op>=</span> <span class=va>self</span>._server_socket.accept()</span>
<span id=cb10-13><a href=#cb10-13 aria-hidden=true tabindex=-1></a>                TCPRelayHandler(<span class=va>self</span>, <span class=va>self</span>._fd_to_handlers, <span class=co># 创建处理单个连接的handler,并将其注册到eventloop中.</span></span>
<span id=cb10-14><a href=#cb10-14 aria-hidden=true tabindex=-1></a>                                <span class=va>self</span>._eventloop, conn[<span class=dv>0</span>], <span class=va>self</span>._config,</span>
<span id=cb10-15><a href=#cb10-15 aria-hidden=true tabindex=-1></a>                                <span class=va>self</span>._dns_resolver, <span class=va>self</span>._is_local)</span>
<span id=cb10-16><a href=#cb10-16 aria-hidden=true tabindex=-1></a>            <span class=cf>except</span> (<span class=pp>OSError</span>, <span class=pp>IOError</span>) <span class=im>as</span> e:</span>
<span id=cb10-17><a href=#cb10-17 aria-hidden=true tabindex=-1></a>                error_no <span class=op>=</span> eventloop.errno_from_exception(e)</span>
<span id=cb10-18><a href=#cb10-18 aria-hidden=true tabindex=-1></a>                <span class=cf>if</span> error_no <span class=kw>in</span> (errno.EAGAIN, errno.EINPROGRESS,</span>
<span id=cb10-19><a href=#cb10-19 aria-hidden=true tabindex=-1></a>                                errno.EWOULDBLOCK):</span>
<span id=cb10-20><a href=#cb10-20 aria-hidden=true tabindex=-1></a>                    <span class=cf>return</span></span>
<span id=cb10-21><a href=#cb10-21 aria-hidden=true tabindex=-1></a>                <span class=cf>else</span>:</span>
<span id=cb10-22><a href=#cb10-22 aria-hidden=true tabindex=-1></a>                    shell.print_exception(e)</span>
<span id=cb10-23><a href=#cb10-23 aria-hidden=true tabindex=-1></a>                    <span class=cf>if</span> <span class=va>self</span>._config[<span class=st>&#39;verbose&#39;</span>]:</span>
<span id=cb10-24><a href=#cb10-24 aria-hidden=true tabindex=-1></a>                        traceback.print_exc()</span>
<span id=cb10-25><a href=#cb10-25 aria-hidden=true tabindex=-1></a>        <span class=cf>else</span>: </span>
<span id=cb10-26><a href=#cb10-26 aria-hidden=true tabindex=-1></a>            <span class=cf>if</span> sock: <span class=co># 如果这个socket不是监听新连接的.那么这意味着我们可以在一个map里面找到它的handler.调用它.</span></span>
<span id=cb10-27><a href=#cb10-27 aria-hidden=true tabindex=-1></a>                handler <span class=op>=</span> <span class=va>self</span>._fd_to_handlers.get(fd, <span class=va>None</span>)</span>
<span id=cb10-28><a href=#cb10-28 aria-hidden=true tabindex=-1></a>                <span class=cf>if</span> handler:</span>
<span id=cb10-29><a href=#cb10-29 aria-hidden=true tabindex=-1></a>                    handler.handle_event(sock, event)</span>
<span id=cb10-30><a href=#cb10-30 aria-hidden=true tabindex=-1></a>            <span class=cf>else</span>:</span>
<span id=cb10-31><a href=#cb10-31 aria-hidden=true tabindex=-1></a>                logging.warn(<span class=st>&#39;poll removed fd&#39;</span>)</span></code></pre></div>
<p>可以在<code>TCPRelayHandler</code>的<a href=https://github.com/shadowsocks/shadowsocks/blob/master/shadowsocks/tcprelay.py#L152>构造函数</a>中看到:</p>
<div class=sourceCode id=cb11><pre class="sourceCode python"><code class="sourceCode python"><span id=cb11-1><a href=#cb11-1 aria-hidden=true tabindex=-1></a> <span class=kw>def</span> <span class=fu>__init__</span>(<span class=va>self</span>, server, fd_to_handlers, loop, local_sock, config,</span>
<span id=cb11-2><a href=#cb11-2 aria-hidden=true tabindex=-1></a>              dns_resolver, is_local):</span>
<span id=cb11-3><a href=#cb11-3 aria-hidden=true tabindex=-1></a>        <span class=va>self</span>._server <span class=op>=</span> server</span>
<span id=cb11-4><a href=#cb11-4 aria-hidden=true tabindex=-1></a>        ...</span>
<span id=cb11-5><a href=#cb11-5 aria-hidden=true tabindex=-1></a>        loop.add(local_sock, eventloop.POLL_IN <span class=op>|</span> eventloop.POLL_ERR,</span>
<span id=cb11-6><a href=#cb11-6 aria-hidden=true tabindex=-1></a>                 <span class=va>self</span>._server)</span>
<span id=cb11-7><a href=#cb11-7 aria-hidden=true tabindex=-1></a>        ...</span></code></pre></div>
<p>这里产生了一个新的疑问,为什么创建好新连接进来的socket对应的handler之后向eventloop中注册处理函数的时候不干脆直接注册成新生成的handler呢?还将它注册成<code>TCPRelay</code>呢?</p>
<p>更新一下疑问列表:</p>
<ol type=1>
<li>daemon进程是怎么启动的呢?为什么要等最后<code>loop.run()</code>之前再<code>set_uesr</code>呢?</li>
<li>为什么dns服务器创建时不读取配置文件?</li>
<li><code>loop</code>是怎么工作的?
<ol type=1>
<li><p>handler这个对象是如何注册到loop中的?[是在什么地方被放进<code>_fdmap</code>的呢?]</p></li>
<li><p><code>handler[1]</code>?</p></li>
<li><p>为什么还需要判断handler不为空,什么情况下它会是空呢?</p></li>
<li><p>为什么<code>events</code>遍历的时候会出来<code>sock</code>
<code>fd</code>和<code>event</code>三个变量呢?<code>epoll</code>不是只会有<code>fd</code>和<code>event</code>两个东西告诉程序是哪个文件发生了什么样的事件吗?</p></li>
<li><p>最后看起来是在判断超时的几行代码的意义是什么呢?</p></li>
</ol></li>
<li>三个server分别是怎么工作的呢?
<ol type=1>
<li>为什么TCPRelay生成完新handler不直接将对应的socket处理函数注册成新生成的
handler,反而要把它注册成生成了这个handler的TCPRelay呢?</li>
</ol></li>
</ol>
<p>不过总体来说整个流程就十分清楚了.</p>
<h2 id=主要流程>主要流程<a hidden class=anchor aria-hidden=true href=#主要流程>¶</a></h2>
<p>我们有一个主循环,这个主事件循环从epoll中拉出发生了IO事件的<code>fd</code>,然后从一个map中找到这个<code>fd</code>对应的handler,调用这个handler的<code>handle_event</code>函数来处理这个<code>fd</code>发生的IO事件.</p>
<p>对于TCP连接的处理而言,我们把所有TCP连接的handle注册成了TCPRelay.也就是说所有TCP
接对应的socket发生IO事件之后,都会调用TCPRelay下面的<code>handle_event</code>.如果是老连接,
我们就从TCPRelay下的另一个<code>fd</code>到handle的map里面找到这个socket对应的handle,调用
handle来处理IO事件;如果是新连接,就创建一个新的<code>TCPRelayHandler</code>,将它写进TCPRelay
下的map.</p>
<p>大致就是这样了.</p>
<p>至于<code>TCPRelaHandler</code>是怎么处理IO事件的.等我想看了,再写一篇文章就是了.</p>
<h2 id=问题>问题<a hidden class=anchor aria-hidden=true href=#问题>¶</a></h2>
<p>那么我们现在把之前遗留的几个问题一一处理一下:</p>
<ol type=1>
<li><p>daemon进程是怎么启动的呢?为什么要等最后<code>loop.run()</code>之前再<code>set_user</code>呢?</p></li>
<li><p>为什么dns服务器创建时不读取配置文件?</p>
<p>这里只是在本地端创建dns不需要读取配置文件.sever端的<a href=https://github.com/shadowsocks/shadowsocks/blob/master/shadowsocks/server.py#L61>代码中</a>可以看到:</p>
<div class=sourceCode id=cb12><pre class="sourceCode python"><code class="sourceCode python"><span id=cb12-1><a href=#cb12-1 aria-hidden=true tabindex=-1></a>dns_resolver <span class=op>=</span> asyncdns.DNSResolver(config[<span class=st>&#39;dns_server&#39;</span>],</span>
<span id=cb12-2><a href=#cb12-2 aria-hidden=true tabindex=-1></a>                                    config[<span class=st>&#39;prefer_ipv6&#39;</span>])</span></code></pre></div></li>
<li><p><code>loop</code>是怎么工作的?</p>
<ol type=1>
<li><p>handler这个对象是如何注册到loop中的?[是在什么地方被放进<code>_fdmap</code>的呢?]</p>
<p>回答过了</p></li>
<li><p><code>handler[1]</code>?</p>
<p>在<a href=https://github.com/shadowsocks/shadowsocks/blob/master/shadowsocks/eventloop.py#L160>这里</a>可以看到</p>
<div class=sourceCode id=cb13><pre class="sourceCode python"><code class="sourceCode python"><span id=cb13-1><a href=#cb13-1 aria-hidden=true tabindex=-1></a><span class=va>self</span>._fdmap <span class=op>=</span> {}  <span class=co># (f, handler)</span></span></code></pre></div>
<p>这里的<code>f</code>是那个file对象.所以这里需要取第二个,第二个才是真正的handler.</p></li>
<li><p>为什么还需要判断handler不为空,什么情况下它会是空呢?</p></li>
<li><p>为什么<code>events</code>遍历的时候会出来<code>sock</code>
<code>fd</code>和<code>event</code>三个变量呢?<code>epoll</code>不是只会有<code>fd</code>和<code>event</code>两个东西告诉程序是哪个文件发生了什么样的事件吗?</p>
<p><a href=https://github.com/shadowsocks/shadowsocks/blob/master/shadowsocks/eventloop.py#L168>这里</a>可以看到,我们通过这个<code>_fdmap</code>取到了<code>fd</code>对应的file对象.</p>
<div class=sourceCode id=cb14><pre class="sourceCode python"><code class="sourceCode python"><span id=cb14-1><a href=#cb14-1 aria-hidden=true tabindex=-1></a><span class=cf>return</span> [(<span class=va>self</span>._fdmap[fd][<span class=dv>0</span>], fd, event) <span class=cf>for</span> fd, event <span class=kw>in</span> events]</span></code></pre></div></li>
<li><p>最后看起来是在判断超时的几行代码的意义是什么呢?</p></li>
</ol></li>
<li><p>三个server分别是怎么工作的呢?</p>
<ol type=1>
<li>为什么TCPRelay生成完新handler不直接将对应的socket处理函数注册成新生成的handler,反而要把它注册成生成了这个handler的TCPRelay呢?</li>
</ol></li>
</ol>
<h2 id=遗留问题>遗留问题<a hidden class=anchor aria-hidden=true href=#遗留问题>¶</a></h2>
<p>那么现在留下的问题是这几个:</p>
<ol type=1>
<li><p>daemon进程是怎么启动的呢?为什么要等最后<code>loop.run()</code>之前再<code>set_user</code>呢?</p></li>
<li><p><code>loop</code>是怎么工作的?</p>
<ol type=1>
<li><p>为什么还需要判断handler不为空,什么情况下它会是空呢?</p></li>
<li><p>最后看起来是在判断超时的几行代码的意义是什么呢?</p></li>
</ol></li>
<li><p>三个server分别是怎么工作的呢?</p>
<ol type=1>
<li>为什么TCPRelay生成完新handler不直接将对应的socket处理函数注册成新生成的handler,反而要把它注册成生成了这个handler的TCPRelay呢?</li>
</ol></li>
</ol>
<p>以及我们接下来还有一些希望了解到的内容,比如<code>TCPRelayHandler</code>到底需要处理哪些IO事件,分别又都是怎么处理的呢?</p>
</div>
<footer class=post-footer>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://blog.black-desk.cn>RAMBLE&BB</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a>
</span>
<span style=display:inline-block;margin-left:1em>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdnjs.cloudflare.com/ajax/libs/Han/3.3.0/han.min.js></script>
<script>(function(){const b=''=='1';if(b)return;let a=document.getElementById("theme-toggle");a.removeEventListener('click',toggleThemeListener),a.addEventListener('click',toggleThemeListener)})()</script>
<script>(function(){let a=document.getElementById('menu');a&&(a.scrollLeft=localStorage.getItem("menu-scroll-position"),a.onscroll=function(){localStorage.setItem("menu-scroll-position",a.scrollLeft)});const b=''=='1',c=''=='1';if(window.matchMedia('(prefers-reduced-motion: reduce)').matches||b||c)return;document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})})()</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>if(window.scrollListeners)for(const a of scrollListeners)window.removeEventListener('scroll',a);window.scrollListeners=[]</script>
<script src=/js/medium-zoom.min.js data-no-instant></script>
<script>(function(){const h='1'=='1';if(!h)return;if(!document.querySelector('.toc')){console.log('no toc found, ignore toc scroll');return}const i=window.scrollListeners,c=document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id]'),d='active';let a=c[0];e(a).classList.add(d);const g=()=>{const b=[];for(const a of c)if(j(a)<5)b.push(a);else break;b.length>0?newActiveHeading=b[b.length-1]:newActiveHeading=c[0],a!=newActiveHeading&&(e(a).classList.remove(d),a=newActiveHeading,e(a).classList.add(d))};let b=null;const f=()=>{b!==null&&clearTimeout(b),b=setTimeout(g,50)};window.addEventListener('scroll',f,!1),i.push(f);function e(a){const b=encodeURI(a.getAttribute('id')).toLowerCase();return document.querySelector(`.toc ul li a[href="#${b}"]`)}function j(a){if(!a.getClientRects().length)return 0;let b=a.getBoundingClientRect();return b.top}})()</script>
</body>
</html>