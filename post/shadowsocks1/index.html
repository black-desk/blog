<!doctype html><html lang=zh-cn dir=auto class=han-init>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Shadowsocks (一) 主循环 | RAMBLE&BB</title>
<meta name=keywords content>
<meta name=description content="这里简单分析一下Shadowsocks这个软件的源码.
因为网上一直有声音认为其源码质量不错.刚好最近在学一些服务器编程相关的知识,所以就来简单分析一下它.
同时由于希望能获得一些阅读源码的经验. 这里会简单记录我读源码的心路历程.
目录结构 首先我们来tree一下,惯例,测试相关的文件就省略了
❯ tree . ├── CHANGES ├── CONTRIBUTING.md ├── Dockerfile ├── LICENSE ├── MANIFEST.in ├── README.md ├── README.rst ├── config.json.example ├── debian │ ├── changelog │ ├── compat │ ├── config.json │ ├── control │ ├── copyright │ ├── docs │ ├── init.d │ ├── install │ ├── rules │ ├── shadowsocks.default │ ├── shadowsocks.manpages │ ├── source │ │ └── format │ ├── sslocal.1 │ └── ssserver.">
<meta name=author content>
<link rel=canonical href=https://blog.black-desk.cn/post/shadowsocks1/>
<link crossorigin=anonymous href=/assets/css/stylesheet.8b523f1730c922e314350296d83fd666efa16519ca136320a93df674d00b6325.css integrity="sha256-i1I/FzDJIuMUNQKW2D/WZu+hZRnKE2MgqT32dNALYyU=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://blog.black-desk.cn/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://blog.black-desk.cn/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://blog.black-desk.cn/favicon-32x32.png>
<link rel=apple-touch-icon href=https://blog.black-desk.cn/apple-touch-icon.png>
<link rel=mask-icon href=https://blog.black-desk.cn/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript><link rel=stylesheet media=all href=https://cdnjs.cloudflare.com/ajax/libs/Han/3.3.0/han.min.css>
<style>.uri:only-child{display:inline-block;width:100%;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}input[type=checkbox]{margin-right:.2em;margin-left:-1.7em;width:1.5em}</style>
<script src=https://code.jquery.com/jquery-3.6.0.slim.min.js></script>
<script>$(document).ready(()=>{$(".uri:only-child").each(function(){(this.nextSibling&&this.nextSibling.nodeValue&&this.nextSibling.nodeValue.trim()||this.previousSibling&&this.previousSibling.nodeValue&&this.previousSibling.nodeValue.trim())&&$(this).css("display","inline").css("white-space","break-spaces")})})</script>
<meta property="og:title" content="Shadowsocks (一) 主循环">
<meta property="og:description" content="这里简单分析一下Shadowsocks这个软件的源码.
因为网上一直有声音认为其源码质量不错.刚好最近在学一些服务器编程相关的知识,所以就来简单分析一下它.
同时由于希望能获得一些阅读源码的经验. 这里会简单记录我读源码的心路历程.
目录结构 首先我们来tree一下,惯例,测试相关的文件就省略了
❯ tree . ├── CHANGES ├── CONTRIBUTING.md ├── Dockerfile ├── LICENSE ├── MANIFEST.in ├── README.md ├── README.rst ├── config.json.example ├── debian │ ├── changelog │ ├── compat │ ├── config.json │ ├── control │ ├── copyright │ ├── docs │ ├── init.d │ ├── install │ ├── rules │ ├── shadowsocks.default │ ├── shadowsocks.manpages │ ├── source │ │ └── format │ ├── sslocal.1 │ └── ssserver.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.black-desk.cn/post/shadowsocks1/"><meta property="article:section" content="post">
<meta property="article:published_time" content="2022-07-10T02:23:58+08:00">
<meta property="article:modified_time" content="2022-07-10T02:23:58+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Shadowsocks (一) 主循环">
<meta name=twitter:description content="这里简单分析一下Shadowsocks这个软件的源码.
因为网上一直有声音认为其源码质量不错.刚好最近在学一些服务器编程相关的知识,所以就来简单分析一下它.
同时由于希望能获得一些阅读源码的经验. 这里会简单记录我读源码的心路历程.
目录结构 首先我们来tree一下,惯例,测试相关的文件就省略了
❯ tree . ├── CHANGES ├── CONTRIBUTING.md ├── Dockerfile ├── LICENSE ├── MANIFEST.in ├── README.md ├── README.rst ├── config.json.example ├── debian │ ├── changelog │ ├── compat │ ├── config.json │ ├── control │ ├── copyright │ ├── docs │ ├── init.d │ ├── install │ ├── rules │ ├── shadowsocks.default │ ├── shadowsocks.manpages │ ├── source │ │ └── format │ ├── sslocal.1 │ └── ssserver.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://blog.black-desk.cn/post/"},{"@type":"ListItem","position":3,"name":"Shadowsocks (一) 主循环","item":"https://blog.black-desk.cn/post/shadowsocks1/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Shadowsocks (一) 主循环","name":"Shadowsocks (一) 主循环","description":"这里简单分析一下Shadowsocks这个软件的源码.\n因为网上一直有声音认为其源码质量不错.刚好最近在学一些服务器编程相关的知识,所以就来简单分析一下它.\n同时由于希望能获得一些阅读源码的经验. 这里会简单记录我读源码的心路历程.\n目录结构 首先我们来tree一下,惯例,测试相关的文件就省略了\n❯ tree . ├── CHANGES ├── CONTRIBUTING.md ├── Dockerfile ├── LICENSE ├── MANIFEST.in ├── README.md ├── README.rst ├── config.json.example ├── debian │ ├── changelog │ ├── compat │ ├── config.json │ ├── control │ ├── copyright │ ├── docs │ ├── init.d │ ├── install │ ├── rules │ ├── shadowsocks.default │ ├── shadowsocks.manpages │ ├── source │ │ └── format │ ├── sslocal.1 │ └── ssserver.","keywords":[],"articleBody":"这里简单分析一下Shadowsocks这个软件的源码.\n因为网上一直有声音认为其源码质量不错.刚好最近在学一些服务器编程相关的知识,所以就来简单分析一下它.\n同时由于希望能获得一些阅读源码的经验. 这里会简单记录我读源码的心路历程.\n目录结构 首先我们来tree一下,惯例,测试相关的文件就省略了\n❯ tree . ├── CHANGES ├── CONTRIBUTING.md ├── Dockerfile ├── LICENSE ├── MANIFEST.in ├── README.md ├── README.rst ├── config.json.example ├── debian │ ├── changelog │ ├── compat │ ├── config.json │ ├── control │ ├── copyright │ ├── docs │ ├── init.d │ ├── install │ ├── rules │ ├── shadowsocks.default │ ├── shadowsocks.manpages │ ├── source │ │ └── format │ ├── sslocal.1 │ └── ssserver.1 ├── setup.py ├── shadowsocks │ ├── __init__.py │ ├── asyncdns.py │ ├── common.py │ ├── crypto │ │ ├── __init__.py │ │ ├── aead.py │ │ ├── hkdf.py │ │ ├── mbedtls.py │ │ ├── openssl.py │ │ ├── rc4_md5.py │ │ ├── sodium.py │ │ ├── table.py │ │ └── util.py │ ├── cryptor.py │ ├── daemon.py │ ├── eventloop.py │ ├── local.py │ ├── lru_cache.py │ ├── manager.py │ ├── server.py │ ├── shell.py │ ├── tcprelay.py │ ├── tunnel.py │ └── udprelay.py ├── snapcraft.yaml ├── tests │ └── ... └── utils ├── README.md ├── autoban.py └── fail2ban └── shadowsocks.conf 11 directories, 106 files 可以看到,主要的源码应该都在shadowsocks目录下,我们可以看到用于加/解密的程序,可以看到处理TCP,UDP连接的程序.\n也可以看到根目录下有DockerFile,以及一个不知道用来干啥的debain文件夹,我猜测是用来生成软件包的.\nsetup.py看起来像是用于安装成Python包的.\n现在对于目录结构有一定认识和猜测了之后,我们可以开始下一步行动了.\n入口 阅读源码肯定要先找入口,至少要知道main在哪里,\n由于实际上使用过这个软件,我知道我们在本地启动的时候输入的命令是sslocal,而在服务器运行的时候输入的命令是ssserver.\n这意味着我们首先得知道这两个命令是如何启动代码的,输入这两个命令之后实际上运行了什么函数.\n在setup.py中我们可以看到:\nentry_points=\"\"\" [console_scripts] sslocal = shadowsocks.local:main ssserver = shadowsocks.server:main \"\"\", 应该不难看出,上面的代码意味着:sslocal对应的是shadowsocks包下的local.py里面的main(),而ssserver对应的是shadowsocks包下的server.py里面的main().\n那么我们先看客户端,也就是sslocal.\n客户端 sslocal main local.py::main这个函数不长,我就直接复制过来了.\n@shell.exception_handle(self_=False, exit_code=1) def main():  shell.check_python()   # fix py2exe  if hasattr(sys, \"frozen\") and sys.frozen in \\  (\"windows_exe\", \"console_exe\"):  p = os.path.dirname(os.path.abspath(sys.executable))  os.chdir(p)   config = shell.get_config(True) # shell大约是一个\"外壳\",用来交互.所以我们使用shell来获得配置文件.  daemon.daemon_exec(config) # 启动daemon进程   logging.info(\"starting local at %s:%d\" %  (config['local_address'], config['local_port'])) # 可以看出来监听的地址和端口是写在配置文件里的.   dns_resolver = asyncdns.DNSResolver() # 启动dns,这个dns貌似是不可配置的,因为config没有被传入.   tcp_server = tcprelay.TCPRelay(config, dns_resolver, True) # 创建新的tcp_server和udp_server  udp_server = udprelay.UDPRelay(config, dns_resolver, True)  loop = eventloop.EventLoop()  dns_resolver.add_to_loop(loop)  tcp_server.add_to_loop(loop)  udp_server.add_to_loop(loop) # 建立一个loop将dns/udp/tcp server都添加到这个loop中.   def handler(signum, _):  logging.warn('received SIGQUIT, doing graceful shutting down..')  tcp_server.close(next_tick=True)  udp_server.close(next_tick=True)  signal.signal(getattr(signal, 'SIGQUIT', signal.SIGTERM), handler) # 注册信号处理函数.   def int_handler(signum, _):  sys.exit(1)  signal.signal(signal.SIGINT, int_handler) # 注册信号处理函数.   daemon.set_user(config.get('user', None))  loop.run() # 启动 这里有关于两个信号SIGQUIT和SIGINT的区别.\n这里可以记下这么几个问题:\ndaemon进程是怎么启动的呢?为什么要等最后loop.run()之前再set_user呢? 为什么dns服务器创建时不读取配置文件? loop是怎么工作的? 三个..._server分别是怎么工作的呢?  可以很明显地看出,我们的主要目标应该是3和4.\n那么接下来的目标就是loop.run()了.\nloop.run 看一个类的时候我们可以先看它是如何工作的.有什么看不懂的地方再回头看它的构造函数之类的东西.\n对于一个过程其实也是一样的.我们可以先看它是如何工作的,然后再看它是怎么初始化的.\n落实到这里,就是说我们可以先看run()看不懂了再去看add_to_loop()\n看看eventloop.py:run()\ndef run(self):  events = []  while not self._stopping:  asap = False  try:  events = self.poll(TIMEOUT_PRECISION) # poll 出一个 events, 从下面看 events 中有 sock, fd 和 event 这三个东西.  except (OSError, IOError) as e:  if errno_from_exception(e) in (errno.EPIPE, errno.EINTR):  # EPIPE: Happens when the client closes the connection  # EINTR: Happens when received a signal  # handles them as soon as possible  asap = True  logging.debug('poll:%s', e)  else:  logging.error('poll:%s', e)  traceback.print_exc()  continue   for sock, fd, event in events:  handler = self._fdmap.get(fd, None) # 获得和 fd 对应的 handler  if handler is not None:  handler = handler[1]  try:  handler.handle_event(sock, fd, event) # 调用 handler 处理 IO 事件.  except (OSError, IOError) as e:  shell.print_exception(e)  now = time.time()  if asap or now - self._last_time = TIMEOUT_PRECISION:  for callback in self._periodic_callbacks:  callback()  self._last_time = now 大致上这个loop的工作流程就是:\npoll出来一个IO事件,看下这个socket有没有对应的handler,有就去调这个handler.\n这里扩充一下问题列表:\ndaemon进程是怎么启动的呢?为什么要等最后loop.run()之前再set_uesr呢? 为什么dns服务器创建时不读取配置文件? loop是怎么工作的? handler这个对象是如何注册到loop中的?[是在什么地方被放进_fdmap的呢?]\n handler[1]?\n 为什么还需要判断handler不为空,什么情况下它会是空呢?\n 为什么events遍历的时候会出来sock,fd和event三个变量呢?epoll不是只会有fd和event两个东西告诉程序是哪个文件发生了什么样的事件吗?\n 最后看起来是在判断超时的几行代码的意义是什么呢?\n  三个server分别是怎么工作的呢?  那么重点应该是3.1,我们可以猜测这个注册发生在add_to_loop里面.但是我们首先可以发现loop有个方法叫add,这里写了_fdmap.\neventloop.py:add()\ndef add(self, f, mode, handler):  fd = f.fileno()  self._fdmap[fd] = (f, handler)  self._impl.register(fd, mode) 这里有一个注册函数.\n在eventloop.py::__init__()中可以看到:我们的_impl就是select.epoll.\n那么我们现在可以看看是谁在调用这个add,以TCPRelay的add_to_loop为例:\nTCPRelay 在这里可以看到\ndef add_to_loop(self, loop):  if self._eventloop:  raise Exception('already add to loop')  if self._closed:  raise Exception('already closed')  self._eventloop = loop  self._eventloop.add(self._server_socket,  eventloop.POLL_IN | eventloop.POLL_ERR, self)  self._eventloop.add_periodic(self.handle_periodic) 这里将自己的_server_socket注册给了loop,这个socket肯定是创建TCPRelay的时候建立的.\n我们来看看这个创建过程:\n在这里 我们可以看到:\ndef __init__(self, config, dns_resolver, is_local, stat_callback=None):  self._config = config  self._is_local = is_local  self._dns_resolver = dns_resolver  self._closed = False  self._eventloop = None  self._fd_to_handlers = {}  self._is_tunnel = False   self._timeout = config['timeout']  self._timeouts = [] # a list for all the handlers  # we trim the timeouts once a while  self._timeout_offset = 0 # last checked position for timeout  self._handler_to_timeouts = {} # key: handler value: index in timeouts   if is_local:  listen_addr = config['local_address']  listen_port = config['local_port']  else:  listen_addr = config['server']  listen_port = config['server_port']  self._listen_port = listen_port   addrs = socket.getaddrinfo(listen_addr, listen_port, 0,  socket.SOCK_STREAM, socket.SOL_TCP)  if len(addrs) == 0:  raise Exception(\"can't get addrinfo for %s:%d\" %  (listen_addr, listen_port))  af, socktype, proto, canonname, sa = addrs[0]  server_socket = socket.socket(af, socktype, proto)  server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)  server_socket.bind(sa)  server_socket.setblocking(False)  if config['fast_open']:  try:  server_socket.setsockopt(socket.SOL_TCP, 23, 5)  except socket.error:  logging.error('warning: fast open is not available')  self._config['fast_open'] = False  server_socket.listen(1024)  self._server_socket = server_socket  self._stat_callback = stat_callback 这就是创建socket,bind,listen的三部曲了.这里还能看到一个Fast Open的设置.\n使用了非阻塞的 socket.\n接下来的问题就是:\nself._eventloop.add(self._server_socket,  eventloop.POLL_IN | eventloop.POLL_ERR, self) 这个地方,向_eventloop注册事件的时候,实际上添加进去的handle是self.\n在上面这里的eventloop.py:run()中:\n...  for sock, fd, event in events:  handler = self._fdmap.get(fd, None) # 获得和fd对应的handler  if handler is not None:  handler = handler[1]  try:  handler.handle_event(sock, fd, event) # 调用handler处理IO事件.  except (OSError, IOError) as e:  shell.print_exception(e) ... 调用了handle_event()方法,那我们来看一下\n这里\n def handle_event(self, sock, fd, event):  # handle events and dispatch to handlers  if sock:  logging.log(shell.VERBOSE_LEVEL, 'fd %d%s', fd,  eventloop.EVENT_NAMES.get(event, event))  if sock == self._server_socket: # 如果是监听新连接的socket  if event \u0026 eventloop.POLL_ERR:  # TODO  raise Exception('server_socket error')  try:  logging.debug('accept')  conn = self._server_socket.accept()  TCPRelayHandler(self, self._fd_to_handlers, # 创建处理单个连接的handler,并将其注册到eventloop中.  self._eventloop, conn[0], self._config,  self._dns_resolver, self._is_local)  except (OSError, IOError) as e:  error_no = eventloop.errno_from_exception(e)  if error_no in (errno.EAGAIN, errno.EINPROGRESS,  errno.EWOULDBLOCK):  return  else:  shell.print_exception(e)  if self._config['verbose']:  traceback.print_exc()  else:   if sock: # 如果这个socket不是监听新连接的.那么这意味着我们可以在一个map里面找到它的handler.调用它.  handler = self._fd_to_handlers.get(fd, None)  if handler:  handler.handle_event(sock, event)  else:  logging.warn('poll removed fd') 可以在TCPRelayHandler的构造函数中看到:\n def __init__(self, server, fd_to_handlers, loop, local_sock, config,  dns_resolver, is_local):  self._server = server  ...  loop.add(local_sock, eventloop.POLL_IN | eventloop.POLL_ERR,  self._server)  ... 这里产生了一个新的疑问,为什么创建好新连接进来的socket对应的handler之后向eventloop中注册处理函数的时候不干脆直接注册成新生成的handler呢?还将它注册成TCPRelay呢?\n更新一下疑问列表:\ndaemon进程是怎么启动的呢?为什么要等最后loop.run()之前再set_uesr呢? 为什么dns服务器创建时不读取配置文件? loop是怎么工作的? handler这个对象是如何注册到loop中的?[是在什么地方被放进_fdmap的呢?]\n handler[1]?\n 为什么还需要判断handler不为空,什么情况下它会是空呢?\n 为什么events遍历的时候会出来sock fd和event三个变量呢?epoll不是只会有fd和event两个东西告诉程序是哪个文件发生了什么样的事件吗?\n 最后看起来是在判断超时的几行代码的意义是什么呢?\n  三个server分别是怎么工作的呢? 为什么TCPRelay生成完新handler不直接将对应的socket处理函数注册成新生成的 handler,反而要把它注册成生成了这个handler的TCPRelay呢?   不过总体来说整个流程就十分清楚了.\n主要流程 我们有一个主循环,这个主事件循环从epoll中拉出发生了IO事件的fd,然后从一个map中找到这个fd对应的handler,调用这个handler的handle_event函数来处理这个fd发生的IO事件.\n对于TCP连接的处理而言,我们把所有TCP连接的handle注册成了TCPRelay.也就是说所有TCP 接对应的socket发生IO事件之后,都会调用TCPRelay下面的handle_event.如果是老连接, 我们就从TCPRelay下的另一个fd到handle的map里面找到这个socket对应的handle,调用 handle来处理IO事件;如果是新连接,就创建一个新的TCPRelayHandler,将它写进TCPRelay 下的map.\n大致就是这样了.\n至于TCPRelaHandler是怎么处理IO事件的.等我想看了,再写一篇文章就是了.\n问题 那么我们现在把之前遗留的几个问题一一处理一下:\ndaemon进程是怎么启动的呢?为什么要等最后loop.run()之前再set_user呢?\n 为什么dns服务器创建时不读取配置文件?\n这里只是在本地端创建dns不需要读取配置文件.sever端的代码中可以看到:\ndns_resolver = asyncdns.DNSResolver(config['dns_server'],  config['prefer_ipv6']) loop是怎么工作的?\nhandler这个对象是如何注册到loop中的?[是在什么地方被放进_fdmap的呢?]\n回答过了\n handler[1]?\n在这里可以看到\nself._fdmap = {} # (f, handler) 这里的f是那个file对象.所以这里需要取第二个,第二个才是真正的handler.\n 为什么还需要判断handler不为空,什么情况下它会是空呢?\n 为什么events遍历的时候会出来sock fd和event三个变量呢?epoll不是只会有fd和event两个东西告诉程序是哪个文件发生了什么样的事件吗?\n这里可以看到,我们通过这个_fdmap取到了fd对应的file对象.\nreturn [(self._fdmap[fd][0], fd, event) for fd, event in events] 最后看起来是在判断超时的几行代码的意义是什么呢?\n  三个server分别是怎么工作的呢?\n为什么TCPRelay生成完新handler不直接将对应的socket处理函数注册成新生成的handler,反而要把它注册成生成了这个handler的TCPRelay呢?   遗留问题 那么现在留下的问题是这几个:\ndaemon进程是怎么启动的呢?为什么要等最后loop.run()之前再set_user呢?\n loop是怎么工作的?\n为什么还需要判断handler不为空,什么情况下它会是空呢?\n 最后看起来是在判断超时的几行代码的意义是什么呢?\n  三个server分别是怎么工作的呢?\n为什么TCPRelay生成完新handler不直接将对应的socket处理函数注册成新生成的handler,反而要把它注册成生成了这个handler的TCPRelay呢?   以及我们接下来还有一些希望了解到的内容,比如TCPRelayHandler到底需要处理哪些IO事件,分别又都是怎么处理的呢?\n","wordCount":"869","inLanguage":"zh-cn","datePublished":"2022-07-10T02:23:58+08:00","dateModified":"2022-07-10T02:23:58+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.black-desk.cn/post/shadowsocks1/"},"publisher":{"@type":"Organization","name":"RAMBLE\u0026BB","logo":{"@type":"ImageObject","url":"https://blog.black-desk.cn/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://blog.black-desk.cn accesskey=h title="RAMBLE&BB (Alt + H)">RAMBLE&BB</a>
<div class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</div>
</div>
<ul id=menu>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Shadowsocks (一) 主循环
</h1>
<div class=post-meta><span title="2022-07-10 02:23:58 +0800 +0800">July 10, 2022</span>
</div>
</header>
<div class=post-content><p>这里简单分析一下Shadowsocks这个软件的源码.</p>
<p>因为网上一直有声音认为其源码质量不错.刚好最近在学一些服务器编程相关的知识,所以就来简单分析一下它.</p>
<p>同时由于希望能获得一些阅读源码的经验.
这里会简单记录我读源码的心路历程.</p>
<h2 id=目录结构>目录结构<a hidden class=anchor aria-hidden=true href=#目录结构>#</a></h2>
<p>首先我们来tree一下,惯例,测试相关的文件就省略了</p>
<pre><code>❯ tree
.
├── CHANGES
├── CONTRIBUTING.md
├── Dockerfile
├── LICENSE
├── MANIFEST.in
├── README.md
├── README.rst
├── config.json.example
├── debian
│   ├── changelog
│   ├── compat
│   ├── config.json
│   ├── control
│   ├── copyright
│   ├── docs
│   ├── init.d
│   ├── install
│   ├── rules
│   ├── shadowsocks.default
│   ├── shadowsocks.manpages
│   ├── source
│   │   └── format
│   ├── sslocal.1
│   └── ssserver.1
├── setup.py
├── shadowsocks
│   ├── __init__.py
│   ├── asyncdns.py
│   ├── common.py
│   ├── crypto
│   │   ├── __init__.py
│   │   ├── aead.py
│   │   ├── hkdf.py
│   │   ├── mbedtls.py
│   │   ├── openssl.py
│   │   ├── rc4_md5.py
│   │   ├── sodium.py
│   │   ├── table.py
│   │   └── util.py
│   ├── cryptor.py
│   ├── daemon.py
│   ├── eventloop.py
│   ├── local.py
│   ├── lru_cache.py
│   ├── manager.py
│   ├── server.py
│   ├── shell.py
│   ├── tcprelay.py
│   ├── tunnel.py
│   └── udprelay.py
├── snapcraft.yaml
├── tests
│   └── ... 
└── utils
    ├── README.md
    ├── autoban.py
    └── fail2ban
        └── shadowsocks.conf

11 directories, 106 files</code></pre>
<p>可以看到,主要的源码应该都在shadowsocks目录下,我们可以看到用于加/解密的程序,可以看到处理TCP,UDP连接的程序.</p>
<p>也可以看到根目录下有DockerFile,以及一个不知道用来干啥的debain文件夹,我猜测是用来生成软件包的.</p>
<p>setup.py看起来像是用于安装成Python包的.</p>
<p>现在对于目录结构有一定认识和猜测了之后,我们可以开始下一步行动了.</p>
<h2 id=入口>入口<a hidden class=anchor aria-hidden=true href=#入口>#</a></h2>
<p>阅读源码肯定要先找入口,至少要知道<code>main</code>在哪里,</p>
<p>由于实际上使用过这个软件,我知道我们在本地启动的时候输入的命令是<code>sslocal</code>,而在服务器运行的时候输入的命令是<code>ssserver</code>.</p>
<p>这意味着我们首先得知道这两个命令是如何启动代码的,输入这两个命令之后实际上运行了什么函数.</p>
<p>在<a href=https://github.com/shadowsocks/shadowsocks/blob/master/setup.py#L21><code>setup.py</code></a>中我们可以看到:</p>
<div class=sourceCode id=cb2><pre class="sourceCode python"><code class="sourceCode python"><span id=cb2-1><a href=#cb2-1 aria-hidden=true tabindex=-1></a>entry_points<span class=op>=</span><span class=st>&quot;&quot;&quot;</span></span>
<span id=cb2-2><a href=#cb2-2 aria-hidden=true tabindex=-1></a><span class=st>[console_scripts]</span></span>
<span id=cb2-3><a href=#cb2-3 aria-hidden=true tabindex=-1></a><span class=st>sslocal = shadowsocks.local:main</span></span>
<span id=cb2-4><a href=#cb2-4 aria-hidden=true tabindex=-1></a><span class=st>ssserver = shadowsocks.server:main</span></span>
<span id=cb2-5><a href=#cb2-5 aria-hidden=true tabindex=-1></a><span class=st>&quot;&quot;&quot;</span>,</span></code></pre></div>
<p>应该不难看出,上面的代码意味着:<code>sslocal</code>对应的是<code>shadowsocks</code>包下的<code>local.py</code>里面的<code>main()</code>,而<code>ssserver</code>对应的是<code>shadowsocks</code>包下的<code>server.py</code>里面的<code>main()</code>.</p>
<p>那么我们先看客户端,也就是<code>sslocal</code>.</p>
<h2 id=客户端-sslocal>客户端 sslocal<a hidden class=anchor aria-hidden=true href=#客户端-sslocal>#</a></h2>
<h3 id=main><code>main</code><a hidden class=anchor aria-hidden=true href=#main>#</a></h3>
<p><a href=https://github.com/shadowsocks/shadowsocks/blob/master/shadowsocks/local.py#L30><code>local.py::main</code></a>这个函数不长,我就直接复制过来了.</p>
<div class=sourceCode id=cb3><pre class="sourceCode python"><code class="sourceCode python"><span id=cb3-1><a href=#cb3-1 aria-hidden=true tabindex=-1></a><span class=at>@shell.exception_handle</span>(self_<span class=op>=</span><span class=va>False</span>, exit_code<span class=op>=</span><span class=dv>1</span>)</span>
<span id=cb3-2><a href=#cb3-2 aria-hidden=true tabindex=-1></a><span class=kw>def</span> main():</span>
<span id=cb3-3><a href=#cb3-3 aria-hidden=true tabindex=-1></a>    shell.check_python()</span>
<span id=cb3-4><a href=#cb3-4 aria-hidden=true tabindex=-1></a></span>
<span id=cb3-5><a href=#cb3-5 aria-hidden=true tabindex=-1></a>    <span class=co># fix py2exe</span></span>
<span id=cb3-6><a href=#cb3-6 aria-hidden=true tabindex=-1></a>    <span class=cf>if</span> <span class=bu>hasattr</span>(sys, <span class=st>&quot;frozen&quot;</span>) <span class=kw>and</span> sys.frozen <span class=kw>in</span> <span class=op>\</span></span>
<span id=cb3-7><a href=#cb3-7 aria-hidden=true tabindex=-1></a>            (<span class=st>&quot;windows_exe&quot;</span>, <span class=st>&quot;console_exe&quot;</span>):</span>
<span id=cb3-8><a href=#cb3-8 aria-hidden=true tabindex=-1></a>        p <span class=op>=</span> os.path.dirname(os.path.abspath(sys.executable))</span>
<span id=cb3-9><a href=#cb3-9 aria-hidden=true tabindex=-1></a>        os.chdir(p)</span>
<span id=cb3-10><a href=#cb3-10 aria-hidden=true tabindex=-1></a></span>
<span id=cb3-11><a href=#cb3-11 aria-hidden=true tabindex=-1></a>    config <span class=op>=</span> shell.get_config(<span class=va>True</span>) <span class=co># shell大约是一个&quot;外壳&quot;,用来交互.所以我们使用shell来获得配置文件.</span></span>
<span id=cb3-12><a href=#cb3-12 aria-hidden=true tabindex=-1></a>    daemon.daemon_exec(config) <span class=co># 启动daemon进程</span></span>
<span id=cb3-13><a href=#cb3-13 aria-hidden=true tabindex=-1></a></span>
<span id=cb3-14><a href=#cb3-14 aria-hidden=true tabindex=-1></a>    logging.info(<span class=st>&quot;starting local at </span><span class=sc>%s</span><span class=st>:</span><span class=sc>%d</span><span class=st>&quot;</span> <span class=op>%</span></span>
<span id=cb3-15><a href=#cb3-15 aria-hidden=true tabindex=-1></a>                 (config[<span class=st>&#39;local_address&#39;</span>], config[<span class=st>&#39;local_port&#39;</span>])) <span class=co># 可以看出来监听的地址和端口是写在配置文件里的.</span></span>
<span id=cb3-16><a href=#cb3-16 aria-hidden=true tabindex=-1></a></span>
<span id=cb3-17><a href=#cb3-17 aria-hidden=true tabindex=-1></a>    dns_resolver <span class=op>=</span> asyncdns.DNSResolver() <span class=co># 启动dns,这个dns貌似是不可配置的,因为config没有被传入. </span></span>
<span id=cb3-18><a href=#cb3-18 aria-hidden=true tabindex=-1></a>    tcp_server <span class=op>=</span> tcprelay.TCPRelay(config, dns_resolver, <span class=va>True</span>) <span class=co># 创建新的tcp_server和udp_server</span></span>
<span id=cb3-19><a href=#cb3-19 aria-hidden=true tabindex=-1></a>    udp_server <span class=op>=</span> udprelay.UDPRelay(config, dns_resolver, <span class=va>True</span>)</span>
<span id=cb3-20><a href=#cb3-20 aria-hidden=true tabindex=-1></a>    loop <span class=op>=</span> eventloop.EventLoop()</span>
<span id=cb3-21><a href=#cb3-21 aria-hidden=true tabindex=-1></a>    dns_resolver.add_to_loop(loop)</span>
<span id=cb3-22><a href=#cb3-22 aria-hidden=true tabindex=-1></a>    tcp_server.add_to_loop(loop)</span>
<span id=cb3-23><a href=#cb3-23 aria-hidden=true tabindex=-1></a>    udp_server.add_to_loop(loop) <span class=co># 建立一个loop将dns/udp/tcp server都添加到这个loop中.</span></span>
<span id=cb3-24><a href=#cb3-24 aria-hidden=true tabindex=-1></a></span>
<span id=cb3-25><a href=#cb3-25 aria-hidden=true tabindex=-1></a>    <span class=kw>def</span> handler(signum, _):</span>
<span id=cb3-26><a href=#cb3-26 aria-hidden=true tabindex=-1></a>        logging.warn(<span class=st>&#39;received SIGQUIT, doing graceful shutting down..&#39;</span>)</span>
<span id=cb3-27><a href=#cb3-27 aria-hidden=true tabindex=-1></a>        tcp_server.close(next_tick<span class=op>=</span><span class=va>True</span>)</span>
<span id=cb3-28><a href=#cb3-28 aria-hidden=true tabindex=-1></a>        udp_server.close(next_tick<span class=op>=</span><span class=va>True</span>)</span>
<span id=cb3-29><a href=#cb3-29 aria-hidden=true tabindex=-1></a>    signal.signal(<span class=bu>getattr</span>(signal, <span class=st>&#39;SIGQUIT&#39;</span>, signal.SIGTERM), handler) <span class=co># 注册信号处理函数.</span></span>
<span id=cb3-30><a href=#cb3-30 aria-hidden=true tabindex=-1></a></span>
<span id=cb3-31><a href=#cb3-31 aria-hidden=true tabindex=-1></a>    <span class=kw>def</span> int_handler(signum, _):</span>
<span id=cb3-32><a href=#cb3-32 aria-hidden=true tabindex=-1></a>        sys.exit(<span class=dv>1</span>)</span>
<span id=cb3-33><a href=#cb3-33 aria-hidden=true tabindex=-1></a>    signal.signal(signal.SIGINT, int_handler) <span class=co># 注册信号处理函数.</span></span>
<span id=cb3-34><a href=#cb3-34 aria-hidden=true tabindex=-1></a></span>
<span id=cb3-35><a href=#cb3-35 aria-hidden=true tabindex=-1></a>    daemon.set_user(config.get(<span class=st>&#39;user&#39;</span>, <span class=va>None</span>))</span>
<span id=cb3-36><a href=#cb3-36 aria-hidden=true tabindex=-1></a>    loop.run() <span class=co># 启动</span></span></code></pre></div>
<p><a href=https://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html>这里</a>有关于两个信号<code>SIGQUIT</code>和<code>SIGINT</code>的区别.</p>
<p>这里可以记下这么几个问题:</p>
<ol type=1>
<li>daemon进程是怎么启动的呢?为什么要等最后<code>loop.run()</code>之前再<code>set_user</code>呢?</li>
<li>为什么dns服务器创建时不读取配置文件?</li>
<li><code>loop</code>是怎么工作的?</li>
<li>三个<code>..._server</code>分别是怎么工作的呢?</li>
</ol>
<p>可以很明显地看出,我们的主要目标应该是3和4.</p>
<p>那么接下来的目标就是<code>loop.run()</code>了.</p>
<h3 id=looprun><code>loop.run</code><a hidden class=anchor aria-hidden=true href=#looprun>#</a></h3>
<p>看一个类的时候我们可以先看它是如何工作的.有什么看不懂的地方再回头看它的构造函数之类的东西.</p>
<p>对于一个过程其实也是一样的.我们可以先看它是如何工作的,然后再看它是怎么初始化的.</p>
<p>落实到这里,就是说我们可以先看<code>run()</code>看不懂了再去看<code>add_to_loop()</code></p>
<p>看看<a href=https://github.com/shadowsocks/shadowsocks/blob/master/shadowsocks/eventloop.py#L193><code>eventloop.py:run()</code></a></p>
<div class=sourceCode id=cb4><pre class="sourceCode python"><code class="sourceCode python"><span id=cb4-1><a href=#cb4-1 aria-hidden=true tabindex=-1></a><span class=kw>def</span> run(<span class=va>self</span>):</span>
<span id=cb4-2><a href=#cb4-2 aria-hidden=true tabindex=-1></a>    events <span class=op>=</span> []</span>
<span id=cb4-3><a href=#cb4-3 aria-hidden=true tabindex=-1></a>    <span class=cf>while</span> <span class=kw>not</span> <span class=va>self</span>._stopping:</span>
<span id=cb4-4><a href=#cb4-4 aria-hidden=true tabindex=-1></a>        asap <span class=op>=</span> <span class=va>False</span></span>
<span id=cb4-5><a href=#cb4-5 aria-hidden=true tabindex=-1></a>        <span class=cf>try</span>:</span>
<span id=cb4-6><a href=#cb4-6 aria-hidden=true tabindex=-1></a>            events <span class=op>=</span> <span class=va>self</span>.poll(TIMEOUT_PRECISION) <span class=co># poll 出一个 events, 从下面看 events 中有 sock, fd 和 event 这三个东西.</span></span>
<span id=cb4-7><a href=#cb4-7 aria-hidden=true tabindex=-1></a>        <span class=cf>except</span> (<span class=pp>OSError</span>, <span class=pp>IOError</span>) <span class=im>as</span> e:</span>
<span id=cb4-8><a href=#cb4-8 aria-hidden=true tabindex=-1></a>            <span class=cf>if</span> errno_from_exception(e) <span class=kw>in</span> (errno.EPIPE, errno.EINTR):</span>
<span id=cb4-9><a href=#cb4-9 aria-hidden=true tabindex=-1></a>                <span class=co># EPIPE: Happens when the client closes the connection</span></span>
<span id=cb4-10><a href=#cb4-10 aria-hidden=true tabindex=-1></a>                <span class=co># EINTR: Happens when received a signal</span></span>
<span id=cb4-11><a href=#cb4-11 aria-hidden=true tabindex=-1></a>                <span class=co># handles them as soon as possible</span></span>
<span id=cb4-12><a href=#cb4-12 aria-hidden=true tabindex=-1></a>                asap <span class=op>=</span> <span class=va>True</span></span>
<span id=cb4-13><a href=#cb4-13 aria-hidden=true tabindex=-1></a>                logging.debug(<span class=st>&#39;poll:</span><span class=sc>%s</span><span class=st>&#39;</span>, e)</span>
<span id=cb4-14><a href=#cb4-14 aria-hidden=true tabindex=-1></a>            <span class=cf>else</span>:</span>
<span id=cb4-15><a href=#cb4-15 aria-hidden=true tabindex=-1></a>                logging.error(<span class=st>&#39;poll:</span><span class=sc>%s</span><span class=st>&#39;</span>, e)</span>
<span id=cb4-16><a href=#cb4-16 aria-hidden=true tabindex=-1></a>                traceback.print_exc()</span>
<span id=cb4-17><a href=#cb4-17 aria-hidden=true tabindex=-1></a>                <span class=cf>continue</span></span>
<span id=cb4-18><a href=#cb4-18 aria-hidden=true tabindex=-1></a></span>
<span id=cb4-19><a href=#cb4-19 aria-hidden=true tabindex=-1></a>        <span class=cf>for</span> sock, fd, event <span class=kw>in</span> events:</span>
<span id=cb4-20><a href=#cb4-20 aria-hidden=true tabindex=-1></a>            handler <span class=op>=</span> <span class=va>self</span>._fdmap.get(fd, <span class=va>None</span>) <span class=co># 获得和 fd 对应的 handler</span></span>
<span id=cb4-21><a href=#cb4-21 aria-hidden=true tabindex=-1></a>            <span class=cf>if</span> handler <span class=kw>is</span> <span class=kw>not</span> <span class=va>None</span>:</span>
<span id=cb4-22><a href=#cb4-22 aria-hidden=true tabindex=-1></a>                handler <span class=op>=</span> handler[<span class=dv>1</span>]</span>
<span id=cb4-23><a href=#cb4-23 aria-hidden=true tabindex=-1></a>                <span class=cf>try</span>:</span>
<span id=cb4-24><a href=#cb4-24 aria-hidden=true tabindex=-1></a>                    handler.handle_event(sock, fd, event) <span class=co># 调用 handler 处理 IO 事件.</span></span>
<span id=cb4-25><a href=#cb4-25 aria-hidden=true tabindex=-1></a>                <span class=cf>except</span> (<span class=pp>OSError</span>, <span class=pp>IOError</span>) <span class=im>as</span> e:</span>
<span id=cb4-26><a href=#cb4-26 aria-hidden=true tabindex=-1></a>                    shell.print_exception(e)</span>
<span id=cb4-27><a href=#cb4-27 aria-hidden=true tabindex=-1></a>        now <span class=op>=</span> time.time()</span>
<span id=cb4-28><a href=#cb4-28 aria-hidden=true tabindex=-1></a>        <span class=cf>if</span> asap <span class=kw>or</span> now <span class=op>-</span> <span class=va>self</span>._last_time <span class=op>&gt;=</span> TIMEOUT_PRECISION:</span>
<span id=cb4-29><a href=#cb4-29 aria-hidden=true tabindex=-1></a>            <span class=cf>for</span> callback <span class=kw>in</span> <span class=va>self</span>._periodic_callbacks:</span>
<span id=cb4-30><a href=#cb4-30 aria-hidden=true tabindex=-1></a>                callback()</span>
<span id=cb4-31><a href=#cb4-31 aria-hidden=true tabindex=-1></a>            <span class=va>self</span>._last_time <span class=op>=</span> now</span></code></pre></div>
<p>大致上这个loop的工作流程就是:</p>
<p>poll出来一个IO事件,看下这个socket有没有对应的handler,有就去调这个handler.</p>
<p>这里扩充一下问题列表:</p>
<ol type=1>
<li>daemon进程是怎么启动的呢?为什么要等最后<code>loop.run()</code>之前再<code>set_uesr</code>呢?</li>
<li>为什么dns服务器创建时不读取配置文件?</li>
<li><code>loop</code>是怎么工作的?
<ol type=1>
<li><p>handler这个对象是如何注册到loop中的?[是在什么地方被放进<code>_fdmap</code>的呢?]</p></li>
<li><p><code>handler[1]</code>?</p></li>
<li><p>为什么还需要判断<code>handler</code>不为空,什么情况下它会是空呢?</p></li>
<li><p>为什么<code>events</code>遍历的时候会出来<code>sock</code>,<code>fd</code>和<code>event</code>三个变量呢?<code>epoll</code>不是只会有<code>fd</code>和<code>event</code>两个东西告诉程序是哪个文件发生了什么样的事件吗?</p></li>
<li><p>最后看起来是在判断超时的几行代码的意义是什么呢?</p></li>
</ol></li>
<li>三个server分别是怎么工作的呢?</li>
</ol>
<p>那么重点应该是3.1,我们可以猜测这个注册发生在<code>add_to_loop</code>里面.但是我们首先可以发现loop有个方法叫add,这里写了<code>_fdmap</code>.</p>
<p><a href=https://github.com/shadowsocks/shadowsocks/blob/master/shadowsocks/eventloop.py#L170><code>eventloop.py:add()</code></a></p>
<div class=sourceCode id=cb5><pre class="sourceCode python"><code class="sourceCode python"><span id=cb5-1><a href=#cb5-1 aria-hidden=true tabindex=-1></a><span class=kw>def</span> add(<span class=va>self</span>, f, mode, handler):</span>
<span id=cb5-2><a href=#cb5-2 aria-hidden=true tabindex=-1></a>    fd <span class=op>=</span> f.fileno()</span>
<span id=cb5-3><a href=#cb5-3 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._fdmap[fd] <span class=op>=</span> (f, handler)</span>
<span id=cb5-4><a href=#cb5-4 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._impl.register(fd, mode)</span></code></pre></div>
<p>这里有一个注册函数.</p>
<p>在<a href=https://github.com/shadowsocks/shadowsocks/blob/master/shadowsocks/eventloop.py#L147><code>eventloop.py::__init__()</code></a>中可以看到:我们的<code>_impl</code>就是<code>select.epoll</code>.</p>
<p>那么我们现在可以看看是谁在调用这个<code>add</code>,以<code>TCPRelay</code>的<code>add_to_loop</code>为例:</p>
<h3 id=tcprelay><code>TCPRelay</code><a hidden class=anchor aria-hidden=true href=#tcprelay>#</a></h3>
<p>在<a href=https://github.com/shadowsocks/shadowsocks/blob/master/shadowsocks/tcprelay.py#L766>这里</a>可以看到</p>
<div class=sourceCode id=cb6><pre class="sourceCode python"><code class="sourceCode python"><span id=cb6-1><a href=#cb6-1 aria-hidden=true tabindex=-1></a><span class=kw>def</span> add_to_loop(<span class=va>self</span>, loop):</span>
<span id=cb6-2><a href=#cb6-2 aria-hidden=true tabindex=-1></a>    <span class=cf>if</span> <span class=va>self</span>._eventloop:</span>
<span id=cb6-3><a href=#cb6-3 aria-hidden=true tabindex=-1></a>        <span class=cf>raise</span> <span class=pp>Exception</span>(<span class=st>&#39;already add to loop&#39;</span>)</span>
<span id=cb6-4><a href=#cb6-4 aria-hidden=true tabindex=-1></a>    <span class=cf>if</span> <span class=va>self</span>._closed:</span>
<span id=cb6-5><a href=#cb6-5 aria-hidden=true tabindex=-1></a>        <span class=cf>raise</span> <span class=pp>Exception</span>(<span class=st>&#39;already closed&#39;</span>)</span>
<span id=cb6-6><a href=#cb6-6 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._eventloop <span class=op>=</span> loop</span>
<span id=cb6-7><a href=#cb6-7 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._eventloop.add(<span class=va>self</span>._server_socket,</span>
<span id=cb6-8><a href=#cb6-8 aria-hidden=true tabindex=-1></a>                        eventloop.POLL_IN <span class=op>|</span> eventloop.POLL_ERR, <span class=va>self</span>)</span>
<span id=cb6-9><a href=#cb6-9 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._eventloop.add_periodic(<span class=va>self</span>.handle_periodic)</span></code></pre></div>
<p>这里将自己的<code>_server_socket</code>注册给了<code>loop</code>,这个<code>socket</code>肯定是创建<code>TCPRelay</code>的时候建立的.</p>
<p>我们来看看这个创建过程:</p>
<p>在<a href=https://github.com/shadowsocks/shadowsocks/blob/master/shadowsocks/tcprelay.py#L723>这里</a>
我们可以看到:</p>
<div class=sourceCode id=cb7><pre class="sourceCode python"><code class="sourceCode python"><span id=cb7-1><a href=#cb7-1 aria-hidden=true tabindex=-1></a><span class=kw>def</span> <span class=fu>__init__</span>(<span class=va>self</span>, config, dns_resolver, is_local, stat_callback<span class=op>=</span><span class=va>None</span>):</span>
<span id=cb7-2><a href=#cb7-2 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._config <span class=op>=</span> config</span>
<span id=cb7-3><a href=#cb7-3 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._is_local <span class=op>=</span> is_local</span>
<span id=cb7-4><a href=#cb7-4 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._dns_resolver <span class=op>=</span> dns_resolver</span>
<span id=cb7-5><a href=#cb7-5 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._closed <span class=op>=</span> <span class=va>False</span></span>
<span id=cb7-6><a href=#cb7-6 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._eventloop <span class=op>=</span> <span class=va>None</span></span>
<span id=cb7-7><a href=#cb7-7 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._fd_to_handlers <span class=op>=</span> {}</span>
<span id=cb7-8><a href=#cb7-8 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._is_tunnel <span class=op>=</span> <span class=va>False</span></span>
<span id=cb7-9><a href=#cb7-9 aria-hidden=true tabindex=-1></a></span>
<span id=cb7-10><a href=#cb7-10 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._timeout <span class=op>=</span> config[<span class=st>&#39;timeout&#39;</span>]</span>
<span id=cb7-11><a href=#cb7-11 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._timeouts <span class=op>=</span> []  <span class=co># a list for all the handlers</span></span>
<span id=cb7-12><a href=#cb7-12 aria-hidden=true tabindex=-1></a>    <span class=co># we trim the timeouts once a while</span></span>
<span id=cb7-13><a href=#cb7-13 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._timeout_offset <span class=op>=</span> <span class=dv>0</span>   <span class=co># last checked position for timeout</span></span>
<span id=cb7-14><a href=#cb7-14 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._handler_to_timeouts <span class=op>=</span> {}  <span class=co># key: handler value: index in timeouts</span></span>
<span id=cb7-15><a href=#cb7-15 aria-hidden=true tabindex=-1></a></span>
<span id=cb7-16><a href=#cb7-16 aria-hidden=true tabindex=-1></a>    <span class=cf>if</span> is_local:</span>
<span id=cb7-17><a href=#cb7-17 aria-hidden=true tabindex=-1></a>        listen_addr <span class=op>=</span> config[<span class=st>&#39;local_address&#39;</span>]</span>
<span id=cb7-18><a href=#cb7-18 aria-hidden=true tabindex=-1></a>        listen_port <span class=op>=</span> config[<span class=st>&#39;local_port&#39;</span>]</span>
<span id=cb7-19><a href=#cb7-19 aria-hidden=true tabindex=-1></a>    <span class=cf>else</span>:</span>
<span id=cb7-20><a href=#cb7-20 aria-hidden=true tabindex=-1></a>        listen_addr <span class=op>=</span> config[<span class=st>&#39;server&#39;</span>]</span>
<span id=cb7-21><a href=#cb7-21 aria-hidden=true tabindex=-1></a>        listen_port <span class=op>=</span> config[<span class=st>&#39;server_port&#39;</span>]</span>
<span id=cb7-22><a href=#cb7-22 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._listen_port <span class=op>=</span> listen_port</span>
<span id=cb7-23><a href=#cb7-23 aria-hidden=true tabindex=-1></a></span>
<span id=cb7-24><a href=#cb7-24 aria-hidden=true tabindex=-1></a>    addrs <span class=op>=</span> socket.getaddrinfo(listen_addr, listen_port, <span class=dv>0</span>,</span>
<span id=cb7-25><a href=#cb7-25 aria-hidden=true tabindex=-1></a>                               socket.SOCK_STREAM, socket.SOL_TCP)</span>
<span id=cb7-26><a href=#cb7-26 aria-hidden=true tabindex=-1></a>    <span class=cf>if</span> <span class=bu>len</span>(addrs) <span class=op>==</span> <span class=dv>0</span>:</span>
<span id=cb7-27><a href=#cb7-27 aria-hidden=true tabindex=-1></a>        <span class=cf>raise</span> <span class=pp>Exception</span>(<span class=st>&quot;can&#39;t get addrinfo for </span><span class=sc>%s</span><span class=st>:</span><span class=sc>%d</span><span class=st>&quot;</span> <span class=op>%</span></span>
<span id=cb7-28><a href=#cb7-28 aria-hidden=true tabindex=-1></a>                        (listen_addr, listen_port))</span>
<span id=cb7-29><a href=#cb7-29 aria-hidden=true tabindex=-1></a>    af, socktype, proto, canonname, sa <span class=op>=</span> addrs[<span class=dv>0</span>]</span>
<span id=cb7-30><a href=#cb7-30 aria-hidden=true tabindex=-1></a>    server_socket <span class=op>=</span> socket.socket(af, socktype, proto)</span>
<span id=cb7-31><a href=#cb7-31 aria-hidden=true tabindex=-1></a>    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class=dv>1</span>)</span>
<span id=cb7-32><a href=#cb7-32 aria-hidden=true tabindex=-1></a>    server_socket.bind(sa)</span>
<span id=cb7-33><a href=#cb7-33 aria-hidden=true tabindex=-1></a>    server_socket.setblocking(<span class=va>False</span>)</span>
<span id=cb7-34><a href=#cb7-34 aria-hidden=true tabindex=-1></a>    <span class=cf>if</span> config[<span class=st>&#39;fast_open&#39;</span>]:</span>
<span id=cb7-35><a href=#cb7-35 aria-hidden=true tabindex=-1></a>        <span class=cf>try</span>:</span>
<span id=cb7-36><a href=#cb7-36 aria-hidden=true tabindex=-1></a>            server_socket.setsockopt(socket.SOL_TCP, <span class=dv>23</span>, <span class=dv>5</span>)</span>
<span id=cb7-37><a href=#cb7-37 aria-hidden=true tabindex=-1></a>        <span class=cf>except</span> socket.error:</span>
<span id=cb7-38><a href=#cb7-38 aria-hidden=true tabindex=-1></a>            logging.error(<span class=st>&#39;warning: fast open is not available&#39;</span>)</span>
<span id=cb7-39><a href=#cb7-39 aria-hidden=true tabindex=-1></a>            <span class=va>self</span>._config[<span class=st>&#39;fast_open&#39;</span>] <span class=op>=</span> <span class=va>False</span></span>
<span id=cb7-40><a href=#cb7-40 aria-hidden=true tabindex=-1></a>    server_socket.listen(<span class=dv>1024</span>)</span>
<span id=cb7-41><a href=#cb7-41 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._server_socket <span class=op>=</span> server_socket</span>
<span id=cb7-42><a href=#cb7-42 aria-hidden=true tabindex=-1></a>    <span class=va>self</span>._stat_callback <span class=op>=</span> stat_callback</span></code></pre></div>
<p>这就是创建socket,bind,listen的三部曲了.这里还能看到一个Fast
Open的设置.</p>
<p>使用了非阻塞的 socket.</p>
<p>接下来的问题就是:</p>
<div class=sourceCode id=cb8><pre class="sourceCode python"><code class="sourceCode python"><span id=cb8-1><a href=#cb8-1 aria-hidden=true tabindex=-1></a><span class=va>self</span>._eventloop.add(<span class=va>self</span>._server_socket,</span>
<span id=cb8-2><a href=#cb8-2 aria-hidden=true tabindex=-1></a>                        eventloop.POLL_IN <span class=op>|</span> eventloop.POLL_ERR, <span class=va>self</span>)</span></code></pre></div>
<p>这个地方,向<code>_eventloop</code>注册事件的时候,实际上添加进去的handle是self.</p>
<p>在上面这里的<a href=https://github.com/shadowsocks/shadowsocks/blob/master/shadowsocks/eventloop.py#L193><code>eventloop.py:run()</code></a>中:</p>
<div class=sourceCode id=cb9><pre class="sourceCode python"><code class="sourceCode python"><span id=cb9-1><a href=#cb9-1 aria-hidden=true tabindex=-1></a>...</span>
<span id=cb9-2><a href=#cb9-2 aria-hidden=true tabindex=-1></a>        <span class=cf>for</span> sock, fd, event <span class=kw>in</span> events:</span>
<span id=cb9-3><a href=#cb9-3 aria-hidden=true tabindex=-1></a>            handler <span class=op>=</span> <span class=va>self</span>._fdmap.get(fd, <span class=va>None</span>) <span class=co># 获得和fd对应的handler</span></span>
<span id=cb9-4><a href=#cb9-4 aria-hidden=true tabindex=-1></a>            <span class=cf>if</span> handler <span class=kw>is</span> <span class=kw>not</span> <span class=va>None</span>:</span>
<span id=cb9-5><a href=#cb9-5 aria-hidden=true tabindex=-1></a>                handler <span class=op>=</span> handler[<span class=dv>1</span>]</span>
<span id=cb9-6><a href=#cb9-6 aria-hidden=true tabindex=-1></a>                <span class=cf>try</span>:</span>
<span id=cb9-7><a href=#cb9-7 aria-hidden=true tabindex=-1></a>                    handler.handle_event(sock, fd, event) <span class=co># 调用handler处理IO事件.</span></span>
<span id=cb9-8><a href=#cb9-8 aria-hidden=true tabindex=-1></a>                <span class=cf>except</span> (<span class=pp>OSError</span>, <span class=pp>IOError</span>) <span class=im>as</span> e:</span>
<span id=cb9-9><a href=#cb9-9 aria-hidden=true tabindex=-1></a>                    shell.print_exception(e)</span>
<span id=cb9-10><a href=#cb9-10 aria-hidden=true tabindex=-1></a>...</span></code></pre></div>
<p>调用了<code>handle_event()</code>方法,那我们来看一下</p>
<p><a href=https://github.com/shadowsocks/shadowsocks/blob/master/shadowsocks/tcprelay.py#L835>这里</a></p>
<div class=sourceCode id=cb10><pre class="sourceCode python"><code class="sourceCode python"><span id=cb10-1><a href=#cb10-1 aria-hidden=true tabindex=-1></a>    <span class=kw>def</span> handle_event(<span class=va>self</span>, sock, fd, event):</span>
<span id=cb10-2><a href=#cb10-2 aria-hidden=true tabindex=-1></a>        <span class=co># handle events and dispatch to handlers</span></span>
<span id=cb10-3><a href=#cb10-3 aria-hidden=true tabindex=-1></a>        <span class=cf>if</span> sock:</span>
<span id=cb10-4><a href=#cb10-4 aria-hidden=true tabindex=-1></a>            logging.log(shell.VERBOSE_LEVEL, <span class=st>&#39;fd </span><span class=sc>%d</span><span class=st> </span><span class=sc>%s</span><span class=st>&#39;</span>, fd,</span>
<span id=cb10-5><a href=#cb10-5 aria-hidden=true tabindex=-1></a>                        eventloop.EVENT_NAMES.get(event, event))</span>
<span id=cb10-6><a href=#cb10-6 aria-hidden=true tabindex=-1></a>        <span class=cf>if</span> sock <span class=op>==</span> <span class=va>self</span>._server_socket: <span class=co># 如果是监听新连接的socket</span></span>
<span id=cb10-7><a href=#cb10-7 aria-hidden=true tabindex=-1></a>            <span class=cf>if</span> event <span class=op>&amp;</span> eventloop.POLL_ERR:</span>
<span id=cb10-8><a href=#cb10-8 aria-hidden=true tabindex=-1></a>                <span class=co># </span><span class=al>TODO</span></span>
<span id=cb10-9><a href=#cb10-9 aria-hidden=true tabindex=-1></a>                <span class=cf>raise</span> <span class=pp>Exception</span>(<span class=st>&#39;server_socket error&#39;</span>)</span>
<span id=cb10-10><a href=#cb10-10 aria-hidden=true tabindex=-1></a>            <span class=cf>try</span>:</span>
<span id=cb10-11><a href=#cb10-11 aria-hidden=true tabindex=-1></a>                logging.debug(<span class=st>&#39;accept&#39;</span>)</span>
<span id=cb10-12><a href=#cb10-12 aria-hidden=true tabindex=-1></a>                conn <span class=op>=</span> <span class=va>self</span>._server_socket.accept()</span>
<span id=cb10-13><a href=#cb10-13 aria-hidden=true tabindex=-1></a>                TCPRelayHandler(<span class=va>self</span>, <span class=va>self</span>._fd_to_handlers, <span class=co># 创建处理单个连接的handler,并将其注册到eventloop中.</span></span>
<span id=cb10-14><a href=#cb10-14 aria-hidden=true tabindex=-1></a>                                <span class=va>self</span>._eventloop, conn[<span class=dv>0</span>], <span class=va>self</span>._config,</span>
<span id=cb10-15><a href=#cb10-15 aria-hidden=true tabindex=-1></a>                                <span class=va>self</span>._dns_resolver, <span class=va>self</span>._is_local)</span>
<span id=cb10-16><a href=#cb10-16 aria-hidden=true tabindex=-1></a>            <span class=cf>except</span> (<span class=pp>OSError</span>, <span class=pp>IOError</span>) <span class=im>as</span> e:</span>
<span id=cb10-17><a href=#cb10-17 aria-hidden=true tabindex=-1></a>                error_no <span class=op>=</span> eventloop.errno_from_exception(e)</span>
<span id=cb10-18><a href=#cb10-18 aria-hidden=true tabindex=-1></a>                <span class=cf>if</span> error_no <span class=kw>in</span> (errno.EAGAIN, errno.EINPROGRESS,</span>
<span id=cb10-19><a href=#cb10-19 aria-hidden=true tabindex=-1></a>                                errno.EWOULDBLOCK):</span>
<span id=cb10-20><a href=#cb10-20 aria-hidden=true tabindex=-1></a>                    <span class=cf>return</span></span>
<span id=cb10-21><a href=#cb10-21 aria-hidden=true tabindex=-1></a>                <span class=cf>else</span>:</span>
<span id=cb10-22><a href=#cb10-22 aria-hidden=true tabindex=-1></a>                    shell.print_exception(e)</span>
<span id=cb10-23><a href=#cb10-23 aria-hidden=true tabindex=-1></a>                    <span class=cf>if</span> <span class=va>self</span>._config[<span class=st>&#39;verbose&#39;</span>]:</span>
<span id=cb10-24><a href=#cb10-24 aria-hidden=true tabindex=-1></a>                        traceback.print_exc()</span>
<span id=cb10-25><a href=#cb10-25 aria-hidden=true tabindex=-1></a>        <span class=cf>else</span>: </span>
<span id=cb10-26><a href=#cb10-26 aria-hidden=true tabindex=-1></a>            <span class=cf>if</span> sock: <span class=co># 如果这个socket不是监听新连接的.那么这意味着我们可以在一个map里面找到它的handler.调用它.</span></span>
<span id=cb10-27><a href=#cb10-27 aria-hidden=true tabindex=-1></a>                handler <span class=op>=</span> <span class=va>self</span>._fd_to_handlers.get(fd, <span class=va>None</span>)</span>
<span id=cb10-28><a href=#cb10-28 aria-hidden=true tabindex=-1></a>                <span class=cf>if</span> handler:</span>
<span id=cb10-29><a href=#cb10-29 aria-hidden=true tabindex=-1></a>                    handler.handle_event(sock, event)</span>
<span id=cb10-30><a href=#cb10-30 aria-hidden=true tabindex=-1></a>            <span class=cf>else</span>:</span>
<span id=cb10-31><a href=#cb10-31 aria-hidden=true tabindex=-1></a>                logging.warn(<span class=st>&#39;poll removed fd&#39;</span>)</span></code></pre></div>
<p>可以在<code>TCPRelayHandler</code>的<a href=https://github.com/shadowsocks/shadowsocks/blob/master/shadowsocks/tcprelay.py#L152>构造函数</a>中看到:</p>
<div class=sourceCode id=cb11><pre class="sourceCode python"><code class="sourceCode python"><span id=cb11-1><a href=#cb11-1 aria-hidden=true tabindex=-1></a> <span class=kw>def</span> <span class=fu>__init__</span>(<span class=va>self</span>, server, fd_to_handlers, loop, local_sock, config,</span>
<span id=cb11-2><a href=#cb11-2 aria-hidden=true tabindex=-1></a>              dns_resolver, is_local):</span>
<span id=cb11-3><a href=#cb11-3 aria-hidden=true tabindex=-1></a>        <span class=va>self</span>._server <span class=op>=</span> server</span>
<span id=cb11-4><a href=#cb11-4 aria-hidden=true tabindex=-1></a>        ...</span>
<span id=cb11-5><a href=#cb11-5 aria-hidden=true tabindex=-1></a>        loop.add(local_sock, eventloop.POLL_IN <span class=op>|</span> eventloop.POLL_ERR,</span>
<span id=cb11-6><a href=#cb11-6 aria-hidden=true tabindex=-1></a>                 <span class=va>self</span>._server)</span>
<span id=cb11-7><a href=#cb11-7 aria-hidden=true tabindex=-1></a>        ...</span></code></pre></div>
<p>这里产生了一个新的疑问,为什么创建好新连接进来的socket对应的handler之后向eventloop中注册处理函数的时候不干脆直接注册成新生成的handler呢?还将它注册成<code>TCPRelay</code>呢?</p>
<p>更新一下疑问列表:</p>
<ol type=1>
<li>daemon进程是怎么启动的呢?为什么要等最后<code>loop.run()</code>之前再<code>set_uesr</code>呢?</li>
<li>为什么dns服务器创建时不读取配置文件?</li>
<li><code>loop</code>是怎么工作的?
<ol type=1>
<li><p>handler这个对象是如何注册到loop中的?[是在什么地方被放进<code>_fdmap</code>的呢?]</p></li>
<li><p><code>handler[1]</code>?</p></li>
<li><p>为什么还需要判断handler不为空,什么情况下它会是空呢?</p></li>
<li><p>为什么<code>events</code>遍历的时候会出来<code>sock</code>
<code>fd</code>和<code>event</code>三个变量呢?<code>epoll</code>不是只会有<code>fd</code>和<code>event</code>两个东西告诉程序是哪个文件发生了什么样的事件吗?</p></li>
<li><p>最后看起来是在判断超时的几行代码的意义是什么呢?</p></li>
</ol></li>
<li>三个server分别是怎么工作的呢?
<ol type=1>
<li>为什么TCPRelay生成完新handler不直接将对应的socket处理函数注册成新生成的
handler,反而要把它注册成生成了这个handler的TCPRelay呢?</li>
</ol></li>
</ol>
<p>不过总体来说整个流程就十分清楚了.</p>
<h2 id=主要流程>主要流程<a hidden class=anchor aria-hidden=true href=#主要流程>#</a></h2>
<p>我们有一个主循环,这个主事件循环从epoll中拉出发生了IO事件的<code>fd</code>,然后从一个map中找到这个<code>fd</code>对应的handler,调用这个handler的<code>handle_event</code>函数来处理这个<code>fd</code>发生的IO事件.</p>
<p>对于TCP连接的处理而言,我们把所有TCP连接的handle注册成了TCPRelay.也就是说所有TCP
接对应的socket发生IO事件之后,都会调用TCPRelay下面的<code>handle_event</code>.如果是老连接,
我们就从TCPRelay下的另一个<code>fd</code>到handle的map里面找到这个socket对应的handle,调用
handle来处理IO事件;如果是新连接,就创建一个新的<code>TCPRelayHandler</code>,将它写进TCPRelay
下的map.</p>
<p>大致就是这样了.</p>
<p>至于<code>TCPRelaHandler</code>是怎么处理IO事件的.等我想看了,再写一篇文章就是了.</p>
<h2 id=问题>问题<a hidden class=anchor aria-hidden=true href=#问题>#</a></h2>
<p>那么我们现在把之前遗留的几个问题一一处理一下:</p>
<ol type=1>
<li><p>daemon进程是怎么启动的呢?为什么要等最后<code>loop.run()</code>之前再<code>set_user</code>呢?</p></li>
<li><p>为什么dns服务器创建时不读取配置文件?</p>
<p>这里只是在本地端创建dns不需要读取配置文件.sever端的<a href=https://github.com/shadowsocks/shadowsocks/blob/master/shadowsocks/server.py#L61>代码中</a>可以看到:</p>
<div class=sourceCode id=cb12><pre class="sourceCode python"><code class="sourceCode python"><span id=cb12-1><a href=#cb12-1 aria-hidden=true tabindex=-1></a>dns_resolver <span class=op>=</span> asyncdns.DNSResolver(config[<span class=st>&#39;dns_server&#39;</span>],</span>
<span id=cb12-2><a href=#cb12-2 aria-hidden=true tabindex=-1></a>                                    config[<span class=st>&#39;prefer_ipv6&#39;</span>])</span></code></pre></div></li>
<li><p><code>loop</code>是怎么工作的?</p>
<ol type=1>
<li><p>handler这个对象是如何注册到loop中的?[是在什么地方被放进<code>_fdmap</code>的呢?]</p>
<p>回答过了</p></li>
<li><p><code>handler[1]</code>?</p>
<p>在<a href=https://github.com/shadowsocks/shadowsocks/blob/master/shadowsocks/eventloop.py#L160>这里</a>可以看到</p>
<div class=sourceCode id=cb13><pre class="sourceCode python"><code class="sourceCode python"><span id=cb13-1><a href=#cb13-1 aria-hidden=true tabindex=-1></a><span class=va>self</span>._fdmap <span class=op>=</span> {}  <span class=co># (f, handler)</span></span></code></pre></div>
<p>这里的<code>f</code>是那个file对象.所以这里需要取第二个,第二个才是真正的handler.</p></li>
<li><p>为什么还需要判断handler不为空,什么情况下它会是空呢?</p></li>
<li><p>为什么<code>events</code>遍历的时候会出来<code>sock</code>
<code>fd</code>和<code>event</code>三个变量呢?<code>epoll</code>不是只会有<code>fd</code>和<code>event</code>两个东西告诉程序是哪个文件发生了什么样的事件吗?</p>
<p><a href=https://github.com/shadowsocks/shadowsocks/blob/master/shadowsocks/eventloop.py#L168>这里</a>可以看到,我们通过这个<code>_fdmap</code>取到了<code>fd</code>对应的file对象.</p>
<div class=sourceCode id=cb14><pre class="sourceCode python"><code class="sourceCode python"><span id=cb14-1><a href=#cb14-1 aria-hidden=true tabindex=-1></a><span class=cf>return</span> [(<span class=va>self</span>._fdmap[fd][<span class=dv>0</span>], fd, event) <span class=cf>for</span> fd, event <span class=kw>in</span> events]</span></code></pre></div></li>
<li><p>最后看起来是在判断超时的几行代码的意义是什么呢?</p></li>
</ol></li>
<li><p>三个server分别是怎么工作的呢?</p>
<ol type=1>
<li>为什么TCPRelay生成完新handler不直接将对应的socket处理函数注册成新生成的handler,反而要把它注册成生成了这个handler的TCPRelay呢?</li>
</ol></li>
</ol>
<h2 id=遗留问题>遗留问题<a hidden class=anchor aria-hidden=true href=#遗留问题>#</a></h2>
<p>那么现在留下的问题是这几个:</p>
<ol type=1>
<li><p>daemon进程是怎么启动的呢?为什么要等最后<code>loop.run()</code>之前再<code>set_user</code>呢?</p></li>
<li><p><code>loop</code>是怎么工作的?</p>
<ol type=1>
<li><p>为什么还需要判断handler不为空,什么情况下它会是空呢?</p></li>
<li><p>最后看起来是在判断超时的几行代码的意义是什么呢?</p></li>
</ol></li>
<li><p>三个server分别是怎么工作的呢?</p>
<ol type=1>
<li>为什么TCPRelay生成完新handler不直接将对应的socket处理函数注册成新生成的handler,反而要把它注册成生成了这个handler的TCPRelay呢?</li>
</ol></li>
</ol>
<p>以及我们接下来还有一些希望了解到的内容,比如<code>TCPRelayHandler</code>到底需要处理哪些IO事件,分别又都是怎么处理的呢?</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
</ul>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2022 <a href=https://blog.black-desk.cn>RAMBLE&BB</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=https://cdnjs.cloudflare.com/ajax/libs/Han/3.3.0/han.min.js></script>
<script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>